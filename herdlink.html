<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>HerdLink - NL Livestock Trade Network Analyser</title>
    <!-- Load Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Load Local CSS -->
    <link rel="stylesheet" type="text/css" href="assets//css/herdlink.css">
    <!-- Load D3.js -->
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- Load jLouvain -->
    <script type="text/javascript" src="assets/js/jLouvain.js"></script>
    <!-- Load fontawesome -->
    <script src="https://kit.fontawesome.com/a14764fea8.js" crossorigin="anonymous"></script>
    <!-- Load Vivus -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vivus/0.3.1/vivus.min.js"></script>
    <!-- Load savesvg.js -->
    <script src="assets/js/savesvg.js"></script>
    <!-- Load jsnetworkx.js -->
    <!-- <script src="script/jsnetworkx.js"></script> -->
    <!-- Load d3-annotation -->
    <script src="assets/js/d3anno.js"></script>
</head>

<body>
    <!-- Introductory overlay -->
    <div id="introOverlay" class="intro-overlay">
        <div class="intro-content">
            <h2>About HerdLink</h2>
            <p>
                HerdLink handles network data locally. Here’s a quick guide on how to use it:
            <ul>
                <li>Choose your CSV file using the file input on the left.</li>
                <li>Switch between graph and map views using the button.</li>
                <li>Click on a node to enter focus mode.</li>
                <li>Explore detailed stats and information in the right panel.</li>
                <li>Click on the focal node again to quit focus mode.</li>
            </ul>
            </p>
            <label>
                <input type="checkbox" id="dontShowAgain"> Do not show again
            </label>
            <br>
            <button id="introOkButton">OK</button>
        </div>
    </div>

    <!-- Radial Labels Container -->
    <div id="radial-labels-container"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999;"></div>

    <!-- Main container: three columns -->
    <div id="mainContainer">
        <!-- Left Column: Controls and Network Stats -->
        <div id="col1">
            <div class="card">
                <!-- TOP SECTION: Fixed heasder & controls -->
                <div class="col1-top">
                    <div class="card-header">
                        <!-- Row 1: Logo/Banner -->
                        <div class="header-row header-row-1">
                            <div class="logo-container">
                                <h4>HerdLink</h4>
                            </div>
                            <div class="logo-svg-container">
                                <svg id="mySVG" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 300">
                                    <circle class="circle blue-bg" cx="58.14" cy="114.94" r="10.72" />
                                    <circle class="line" cx="58.25" cy="115" r="15.33" />
                                    <!-- Step 1 -->
                                    <!-- Connectors -->
                                    <path data-async class="line" d="M58.25 99.67V70" />
                                    <path data-async class="line" d="M70.06 105.22l32.11-26.66" />
                                    <path data-async class="line" d="M70.54 124.17l23.61 19.3" />
                                    <path data-async class="line" d="M55.75 130.13L40.25 211" />
                                    <path class="line" d="M45.96 124.17l-31.81 19.72" />
                                    <!-- Node Outlines -->
                                    <circle data-async class="line" cx="58.25" cy="66" r="4.25" />
                                    <circle data-async class="line" cx="105.25" cy="76" r="4.25" />
                                    <circle data-async class="line" cx="97.25" cy="146" r="4.25" />
                                    <circle data-async class="line" cx="40.25" cy="215" r="4.25" />
                                    <circle class="line" cx="10.75" cy="146" r="4.25" />
                                    <!-- Node Fills -->
                                    <circle data-async class="circle step1" cx="58.25" cy="66" r="4" />
                                    <circle data-async class="circle step1" cx="105.25" cy="76" r="4" />
                                    <circle data-async class="circle step1" cx="97.25" cy="146" r="4" />
                                    <circle data-async class="circle step1" cx="40.25" cy="215" r="4" />
                                    <circle class="circle step1" cx="10.75" cy="146" r="4" />
                                    <!-- Step 2 -->
                                    <!-- Connectors -->
                                    <path data-async class="line" d="M61.42 63.56l46.62-34.68" />
                                    <path data-async class="line" d="M109.25 76l42-.01" />
                                    <path data-async class="line" d="M99.8 142.92l52.9-63.84" />
                                    <path data-async class="line" d="M94.7 149.08l-52 62.76" />
                                    <path class="line" d="M38.55 211.38l-26.23-61.7" />
                                    <!-- Node Outlines -->
                                    <circle data-async class="line" cx="111.25" cy="26.5" r="4.25" />
                                    <circle class="line" cx="155.25" cy="75.99" r="4.25" />
                                    <!-- Node Fills -->
                                    <circle data-async class="circle step2" cx="111.25" cy="26.5" r="4" />
                                    <circle class="circle step2" cx="155.25" cy="75.99" r="4" />
                                    <!-- Step 3 -->
                                    <!-- Connectors -->
                                    <path data-async class="line" d="M152.44 73.14L113.89 29.5" />
                                    <path data-async class="line" d="M155.25 71.99l-7.5-54.49" />
                                    <path data-async class="line" d="M158.18 78.71l34.13 33.41" />
                                    <path class="line" d="M43.97 213.54l67.78-25.53" />
                                    <!-- Node Outlines -->
                                    <circle data-async class="line" cx="147.75" cy="13.5" r="4.25" />
                                    <circle data-async class="line" cx="195.08" cy="115" r="4.25" />
                                    <circle class="line" cx="115.75" cy="186.5" r="4.25" />
                                    <!-- Node Fills -->
                                    <circle data-async class="circle step3" cx="147.75" cy="13.5" r="4" />
                                    <circle data-async class="circle step3" cx="195.08" cy="115" r="4" />
                                    <circle data-async class="circle step3" cx="115.75" cy="186.5" r="4" />
                                    <!-- Step 4 -->
                                    <!-- Connectors -->
                                    <path data-async class="line" d="M195.77 111.06l9.29-53.12" />
                                    <path data-async class="line" d="M197.84 117.9l38.66 40.7" />
                                    <path data-async class="line" d="M119.69 185.82l53.56-8.67" />
                                    <path class="line" d="M118.46 189.43l96.11 94.43" />
                                    <!-- Node Outlines -->
                                    <circle data-async class="line" cx="205.75" cy="54" r="4.25" />
                                    <circle data-async class="line" cx="239.25" cy="161.5" r="4.25" />
                                    <circle data-async class="line" cx="177.25" cy="176.5" r="4.25" />
                                    <circle class="line" cx="217.42" cy="286.67" r="4.25" />
                                    <!-- Node Fills -->
                                    <circle data-async class="circle step4" cx="205.75" cy="54" r="4" />
                                    <circle data-async class="circle step4" cx="239.25" cy="161.5" r="4" />
                                    <circle data-async class="circle step4" cx="177.25" cy="176.5" r="4" />
                                    <circle class="circle step4" cx="217.42" cy="286.67" r="4" />
                                    <!-- Step 5 -->
                                    <!-- Connectors -->
                                    <path data-async class="line" d="M235.46 162.78l-54.21 12.78" />
                                    <path data-async class="line" d="M237 164.81l-36.21 47.1" />
                                    <path class="line" d="M179.12 180.03l17.33 31.4" />
                                    <!-- Node Outlines -->
                                    <circle class="line" cx="198.25" cy="215" r="4.25" />
                                    <!-- Node Fills -->
                                    <circle class="circle step5" cx="198.25" cy="215" r="4" />
                                </svg>
                            </div>
                        </div>

                        <!-- Row 2: File Input -->
                        <div class="header-row header-row-2">
                            <div class="file-upload-container">
                                <label for="csvFileInput">
                                    <i class="fa-solid fa-upload"></i>Choose File
                                </label>
                                <input type="file" id="csvFileInput" accept=".csv">
                                <span id="fileName" class="file-name">No file selected</span>
                            </div>
                        </div>

                        <!-- Row 3: Switch Button -->
                        <div class="header-row header-row-3">
                            <div class="switch-button-container">
                                <button id="toggleModeButton" class="btn graph-mode" disabled>
                                    <span class="btn-text"><i class="fa-solid fa-map-location-dot"></i> Switch to
                                        Map</span>
                                </button>
                            </div>
                        </div>

                    </div>
                </div>
                <!-- BOTTOM SECTION: Scrollable content -->
                <div class="col1-bottom">
                    <details class="collapsible-section" open>
                        <summary>
                            <span class="header-text"><i class="fa-solid fa-chart-simple" id="statsHeader"></i>
                                Statistics</span>
                        </summary>
                        <div class="section-content">
                            <div id="networkStats" class="panel"></div>
                        </div>
                    </details>
                    <details class="collapsible-section" open>
                        <summary>
                            <span class="header-text"><i class="fa-solid fa-arrows-to-dot" id="hotspotsHeader"></i>
                                Hotspots</span>
                        </summary>
                        <div class="section-content">
                            <div id="topMetrics"></div>
                        </div>
                    </details>
                    <details class="collapsible-section" open>
                        <summary>
                            <span class="header-text"><i class="fa-solid fa-circle-nodes" id="sccHeader"></i> Trade
                                Clusters</span>
                        </summary>
                        <div class="section-content">
                            <div id="sccOutput" class="panel"></div>
                        </div>
                    </details>
                </div>
            </div>
        </div>

        <!-- Middle Column: Graph/Map -->
        <div id="col2">
            <button id="screenshotButton" class="screenshot-button" disabled>
                <i class="fa-solid fa-camera"></i> Screenshot
            </button>
            <button id="restoreButton" class="restore-button" disabled>
                <i class="fa-solid fa-arrows-rotate"></i> Restore
            </button>
            <div id="spectralRadiusDisplay" class="spectral-radius-display">
                <i class="fa-solid fa-virus"></i> Risk Score: <span class="current-sr">----</span> <span
                    class="initial-sr">(----)</span>
            </div>
            <svg id="mainFigureSVG"></svg>
            <div class="watermark">
                <span class="watermark-text"></span>
                <img src="assets/files/herdlink/WUR_ZW_standard_2021.svg" class="watermark-logo">
            </div>
        </div>

        <!-- Right Column: Trade Table -->
        <div id="col3">
            <div id="tradeInfo">
                <div id="tradePanel" class="panel"></div>
                <p></p>
                <div id="inArboContainer" class="panel">
                    <h4>
                        <i class="fa-solid fa-sitemap"></i> Major Import Structure
                        <span class="info-container">
                            <i class="fa-solid fa-circle-question"></i>
                            <span class="info-box">
                                In a trade network, "major import structure" is an "in-arborescence", which is a
                                directed tree where each node (except the root) has exactly one major incoming route,
                                showing how livestocks flow (mainly) inward toward the chosen root region.
                            </span>
                        </span>
                    </h4>
                    <svg id="inArboSVG"></svg>
                </div>
            </div>
        </div>
    </div>
    </div>

    <script>
        // ---- Global Variables ----
        const svg = d3.select("#col2 svg");
        let containerCol2 = document.getElementById("col2");
        let w = containerCol2.clientWidth, h = containerCol2.clientHeight;
        svg.attr("viewBox", `0 0 ${w} ${h}`);
        let currentMode = "graph";
        let nlMapData = null, nlLabelPoints = null;
        let forceSim = null, linkSelection, nodeEnter, labelSelection;
        let allLinks = [], allNodes = [];
        let selectedNodeData = null;
        let hotspots = null;
        let hotspotsMax = null;
        const hotspotColors = {
            inDegree: "#08FF08",   // Fluorescent Green
            outDegree: "#05C3DD",  // Aqua Blue
            betweenness: "#ff007f", // Bright Pink
            pageRank: "#FFD600",    // Vivid Yellow
            eigenvector: "#8a2be2" // Strong Purple
        };
        const nodeAnnoType = d3.annotationCallout;
        const linkAnnoType = d3.annotationCallout;
        let hoveredNode = null;
        let hoveredLink = null;
        let annotationGroup = null;
        const metricNames = ["inDegree", "outDegree", "betweenness", "pageRank", "eigenvector"];
        let top3ForMetric = {};
        let initialSpectralRadius = 0;

        // ---- Load GeoJSON Files ----
        d3.json("assets/files/herdlink/nl_corop.geojson").then(data => { nlMapData = data; })
            .catch(error => { console.error("Error loading nl_corop.geojson:", error); });
        d3.json("assets/files/herdlink/nl_corop_labelpoint.geojson").then(data => { nlLabelPoints = data; })
            .catch(error => { console.error("Error loading nl_corop_labelpoint.geojson:", error); });

        // ---- Define Arrow Marker ----
        svg.append("defs").append("marker")
            .attr("id", "arrow")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 15)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "#fafceb");

        // ---- Disable mode toggle button initially ----
        d3.select("#toggleModeButton").attr("disabled", true);

        // ---- Toggle Button Event ----
        d3.select("#toggleModeButton").on("click", () => {
            if (currentMode === "graph") {
                switchToMapMode();
                d3.select("#toggleModeButton")
                    .html('<span class="btn-text"><i class="fa-solid fa-hexagon-nodes"></i> Switch to Graph</span>')
                    .classed("map-mode", true)
                    .classed("graph-mode", false);
                currentMode = "map";
            } else {
                switchToGraphMode();
                d3.select("#toggleModeButton")
                    .html('<span class="btn-text"><i class="fa-solid fa-map-location-dot"></i> Switch to Map</span>')
                    .classed("graph-mode", true)
                    .classed("map-mode", false);
                currentMode = "graph";
            }
        });

        // ---- Helper: Map COROP Code to statnaam ----
        function getStatnaam(code) {
            if (nlLabelPoints && nlLabelPoints.features) {
                let feat = nlLabelPoints.features.find(f => f.properties.statcode === code);
                return feat ? feat.properties.statnaam : code;
            }
            return code;
        }

        function updateNetworkStats(nodes, links) {
            // Filter out disabled links
            const enabledLinks = links.filter(d => !d.disabled);

            const totalNodes = nodes.length;
            const totalEdges = enabledLinks.length;
            const totalTradeVolume = d3.sum(enabledLinks, d => d.weight);
            const avgTradeEdge = totalEdges > 0 ? (totalTradeVolume / totalEdges).toFixed(2) : 0;
            const avgTradeNode = totalNodes > 0 ? (d3.sum(nodes, d => d.tradeTotal) / totalNodes).toFixed(2) : 0;

            // Compute connectivity: how many connected components (undirected) exist?
            const numComponents = getNumberOfConnectedComponents(nodes, enabledLinks);

            // Compute (or approximate) modularity on the enabled links
            let { partition, modularity } = computeModularity(nodes, enabledLinks);

            let html = `
                <div class="stats-container">
                <div class="stat-item">
                    <span class="stat-label">COROP Areas</span>
                    <span class="stat-value">${totalNodes}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Trade Routes</span>
                    <span class="stat-value">${totalEdges}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Total Volume</span>
                    <span class="stat-value">${totalTradeVolume}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg. Volume/Route</span>
                    <span class="stat-value">${avgTradeEdge}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg. Volume/Area</span>
                    <span class="stat-value">${avgTradeNode}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Connected Components
                    <span class="info-container">
                        <i class="fa-solid fa-circle-question"></i>
                        <span class="info-box">
                        Count of “connected components” in the network. A “connected component” is a set of nodes where each node is reachable from any other node in that set (via some path of edges). Therefore, the number of connected components is a measure of how fragmented the network is.
                        </span>
                    </span>
                    </span>
                    <span class="stat-value">${numComponents}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Modularity
                    <span class="info-container">
                        <i class="fa-solid fa-circle-question"></i>
                        <span class="info-box">
                        "Modularity" measures the strength of community structure in a network. It compares the actual density of links within communities to a random network. Higher modularity value (0 to 1) indicates well-separated, strongly connected communities, while lower value suggests weaker or no community structure.
                        </span>
                    </span>
                    </span>
                    <span class="stat-value">${modularity.toFixed(0)}</span>
                </div>
                </div>
            `;

            document.getElementById("networkStats").innerHTML = html;
            attachInfoBoxListeners();
        }

        /**
         * getNumberOfConnectedComponents(nodes, links)
         * Treats links as undirected, returns how many connected components are in the graph.
         */
        function getNumberOfConnectedComponents(nodes, links) {
            // Build an undirected adjacency list
            const adjList = {};
            nodes.forEach(n => { adjList[n.id] = new Set(); });

            links.forEach(e => {
                // Note: if e.source or e.target is an object, use e.source.id, e.target.id
                const s = (typeof e.source === "object") ? e.source.id : e.source;
                const t = (typeof e.target === "object") ? e.target.id : e.target;
                // add each direction for undirected
                adjList[s].add(t);
                adjList[t].add(s);
            });

            // BFS or DFS to count components
            let visited = new Set();
            let componentCount = 0;

            function bfs(startId) {
                let queue = [startId];
                visited.add(startId);
                while (queue.length > 0) {
                    let curr = queue.shift();
                    adjList[curr].forEach(neighborId => {
                        if (!visited.has(neighborId)) {
                            visited.add(neighborId);
                            queue.push(neighborId);
                        }
                    });
                }
            }

            // For each node, if not visited, BFS from it => found a new component
            nodes.forEach(n => {
                if (!visited.has(n.id)) {
                    componentCount++;
                    bfs(n.id);
                }
            });

            return componentCount;
        }

        function computeModularity(nodes, links) {
            // Build an array of [sourceId, targetId, weight].
            let edgesForLouvain = [];
            links.forEach(link => {
                let s = (typeof link.source === "object") ? link.source.id : link.source;
                let t = (typeof link.target === "object") ? link.target.id : link.target;
                let w = link.weight;
                // For an undirected approach, add just once.
                edgesForLouvain.push([s, t, w]);
            });

            let nodeIds = nodes.map(n => n.id);

            // Now pass an array to .edges(...)
            let community = jLouvain()
                .nodes(nodeIds)
                .edges(edgesForLouvain);

            // Run the algorithm
            let results = community();    // node => community
            let assignments = results['communities']
            let modularity = results['modularity'];

            var max_community_number = 0;
            nodeIds.forEach(function (d) {
                nodes.find(function (n) {
                    return n.id == d;
                }).community = assignments[d];
                max_community_number = max_community_number < assignments[d] ?
                    assignments[d] : max_community_number;
            });

            return {
                partition: assignments,
                modularity: modularity
            };
        }

        /**
         * Computes eigenvector centrality for the graph using only enabled links.
         * The graph is treated as undirected.
         *
         * @param {Array} nodes - Array of node objects, each with at least { id: string }.
         * @param {Array} links - Array of link objects, each with { source, target, weight, disabled }.
         * @param {Object} [options] - Optional parameters: { maxIter, tol }.
         * @returns {Object} An object mapping node IDs to their computed eigenvector centrality.
         */
        function computeEigenvectorCentrality(nodes, links, options = {}) {
            // Default options: maximum iterations and tolerance.
            const maxIter = options.maxIter || 100;
            const tol = options.tol || 1e-6;

            // Filter out disabled links.
            const enabledLinks = links.filter(link => !link.disabled);

            // Build an undirected adjacency list.
            // For each node, create an object to map each neighbor to the sum of weights.
            const adj = {};
            nodes.forEach(n => {
                adj[n.id] = {};
            });
            enabledLinks.forEach(link => {
                const s = (typeof link.source === "object") ? link.source.id : link.source;
                const t = (typeof link.target === "object") ? link.target.id : link.target;
                const w = link.weight || 1;
                if (!adj[s][t]) {
                    adj[s][t] = 0;
                }
                if (!adj[t][s]) {
                    adj[t][s] = 0;
                }
                adj[s][t] += w;
                adj[t][s] += w;
            });

            // Initialize centrality for each node with a value of 1.
            let centrality = {};
            nodes.forEach(n => {
                centrality[n.id] = 1;
            });

            // Power iteration: update centrality until convergence.
            for (let iter = 0; iter < maxIter; iter++) {
                let newCentrality = {};
                let norm = 0;

                // Compute new centrality values.
                nodes.forEach(n => {
                    let sum = 0;
                    for (let neighbor in adj[n.id]) {
                        sum += adj[n.id][neighbor] * centrality[neighbor];
                    }
                    newCentrality[n.id] = sum;
                    norm += sum * sum;
                });
                norm = Math.sqrt(norm);

                // Normalize the new centrality vector.
                nodes.forEach(n => {
                    newCentrality[n.id] /= norm;
                });

                // Check convergence.
                let diff = 0;
                nodes.forEach(n => {
                    diff = Math.max(diff, Math.abs(newCentrality[n.id] - centrality[n.id]));
                });
                centrality = newCentrality;
                if (diff < tol) break;
            }

            return centrality;
        }

        /**
         * computeHotSpotMetrics(allNodes, allLinks)
         *
         * For each node, computes:
         *  1) Weighted In-Degree
         *  2) Weighted Out-Degree
         *  3) Weighted Betweenness Centrality (using a simplified Brandes approach)
         *  4) Weighted PageRank (iterative approach)
         *  5) Eigenvector Centrality (new metric for disease transmission importance)
         *
         * Returns an object: {
         *    [nodeId]: {
         *       inDegree: Number,
         *       outDegree: Number,
         *       betweenness: Number,
         *       pageRank: Number,
         *       eigenvector: Number
         *    },
         *    ...
         * }
         *
         * allNodes: array of { id, ... }
         * allLinks: array of { source, target, weight, disabled }
         */
        function computeHotSpotMetrics(allNodes, allLinks) {
            // Filter out disabled links.
            const enabledLinks = allLinks.filter(link => !link.disabled);

            //////////////////////////////////////////////
            // 1) Weighted In-Degree & Out-Degree
            //////////////////////////////////////////////
            const metrics = {};
            allNodes.forEach(n => {
                metrics[n.id] = {
                    inDegree: 0,
                    outDegree: 0,
                    betweenness: 0,
                    pageRank: 1, // initial PR guess
                    eigenvector: 0  // will be computed later
                };
            });

            // Use only enabled links.
            enabledLinks.forEach(link => {
                const s = (typeof link.source === "object") ? link.source.id : link.source;
                const t = (typeof link.target === "object") ? link.target.id : link.target;
                const w = link.weight || 1;
                if (metrics[s]) {
                    metrics[s].outDegree += w;
                }
                if (metrics[t]) {
                    metrics[t].inDegree += w;
                }
            });

            //////////////////////////////////////////////
            // 2) Weighted Betweenness Centrality
            //    (Simplified Brandes approach)
            //////////////////////////////////////////////
            // Build adjacency for a weighted directed graph using only enabled links.
            const adj = {};
            allNodes.forEach(n => { adj[n.id] = []; });
            enabledLinks.forEach(e => {
                const s = (typeof e.source === "object") ? e.source.id : e.source;
                const t = (typeof e.target === "object") ? e.target.id : e.target;
                const w = e.weight || 1;
                // For cost, use 1/weight.
                adj[s].push({ target: t, cost: 1 / w });
            });

            function brandesBetweenness() {
                allNodes.forEach(n => {
                    metrics[n.id].betweenness = 0;
                });
                // For each node s:
                allNodes.forEach(sNode => {
                    const s = sNode.id;
                    let S = [];
                    let P = {};
                    let sigma = {};
                    let dist = {};
                    let delta = {};
                    allNodes.forEach(n => {
                        P[n.id] = [];
                        sigma[n.id] = 0;
                        dist[n.id] = Infinity;
                        delta[n.id] = 0;
                    });
                    sigma[s] = 1;
                    dist[s] = 0;

                    // Graph search:
                    let queue = [s];
                    while (queue.length > 0) {
                        let v = queue.shift();
                        S.push(v);
                        adj[v].forEach(edge => {
                            let w = edge.target;
                            let cost = edge.cost;
                            let vwDist = dist[v] + cost;
                            if (vwDist < dist[w]) {
                                dist[w] = vwDist;
                                sigma[w] = 0;
                                P[w] = [];
                                queue.push(w);
                            }
                            if (Math.abs(vwDist - dist[w]) < 1e-9) {
                                sigma[w] += sigma[v];
                                P[w].push(v);
                            }
                        });
                        // Sorting queue to simulate Dijkstra's algorithm.
                        queue.sort((a, b) => dist[a] - dist[b]);
                    }

                    // Back-propagation.
                    while (S.length > 0) {
                        let w = S.pop();
                        P[w].forEach(v => {
                            delta[v] += (sigma[v] / sigma[w]) * (1 + delta[w]);
                        });
                        if (w !== s) {
                            metrics[w].betweenness += delta[w];
                        }
                    }
                });
            }
            brandesBetweenness();

            //////////////////////////////////////////////
            // 3) Weighted PageRank (Simplified)
            //////////////////////////////////////////////
            let d = 0.85;
            let N = allNodes.length;
            let outWeightSum = {};
            allNodes.forEach(n => {
                outWeightSum[n.id] = 0;
            });
            enabledLinks.forEach(link => {
                const s = (typeof link.source === "object") ? link.source.id : link.source;
                const w = link.weight || 1;
                outWeightSum[s] += w;
            });

            function doPageRankIteration() {
                let newPR = {};
                allNodes.forEach(n => {
                    newPR[n.id] = (1 - d) / N;
                });
                enabledLinks.forEach(link => {
                    let vId = (typeof link.source === "object") ? link.source.id : link.source;
                    let uId = (typeof link.target === "object") ? link.target.id : link.target;
                    let w = link.weight || 1;
                    if (outWeightSum[vId] > 0) {
                        let contrib = d * (metrics[vId].pageRank * (w / outWeightSum[vId]));
                        newPR[uId] += contrib;
                    }
                });
                allNodes.forEach(n => {
                    metrics[n.id].pageRank = newPR[n.id];
                });
            }
            for (let i = 0; i < 20; i++) {
                doPageRankIteration();
            }

            //////////////////////////////////////////////
            // 4) Eigenvector Centrality
            //////////////////////////////////////////////
            // Compute eigenvector centrality using only enabled links.
            const eigenCentrality = computeEigenvectorCentrality(allNodes, enabledLinks);
            allNodes.forEach(n => {
                metrics[n.id].eigenvector = eigenCentrality[n.id];
            });

            //////////////////////////////////////////////
            // Return final metrics.
            //////////////////////////////////////////////
            return metrics;
        }

        /**
         * printHotSpots(metrics, containerId)
         *
         * Creates multiple sub-tables, one per metric (inDegree, outDegree, betweenness, pageRank).
         * Each sub-table lists the nodes in descending order of that metric.
         * 
         * Layout example:
         *   <h4>inDegree</h4>
         *   <table>
         *     <tr><th>Node</th><th>inDegree</th></tr>
         *     <tr><td>A</td><td>30.00</td></tr>
         *     ...
         *   </table>
         *
         * @param {Object} metrics - e.g. {
         *     "A": { inDegree: 10, outDegree: 20, betweenness: 5.3, pageRank: 0.12 },
         *     "B": { inDegree: 12, outDegree: 9,  betweenness: 3.8, pageRank: 0.20 },
         *   }
         * @param {String} containerId - e.g. "topMetrics"
         * @param {Number} n - Number of top nodes per metric to display
         */
        function printHotSpots(metrics, containerId, n) {
            const container = document.getElementById(containerId);
            if (!container) {
                console.warn("No container found for ID:", containerId);
                return;
            }

            // Clear the container
            container.innerHTML = "";

            // Mapping from metricNames to display names
            const metricDisplayNames = {
                inDegree: "Vulnerable (by In-Degree)",
                outDegree: "Seeding (by Out-Degree)",
                betweenness: "Bottleneck (by Betweenness)",
                pageRank: "Sink (by PageRank)",
                eigenvector: "Amplifier (by Eigenvector)"
            };

            // Helper: sort all nodes by the specified metric (descending)
            function sortByMetric(metricName) {
                const arr = Object.keys(metrics).map(nodeId => ({
                    nodeId,
                    value: metrics[nodeId][metricName] || 0
                }));
                arr.sort((a, b) => b.value - a.value); // descending
                return arr;
            }

            // For each metric, show top N items
            metricNames.forEach(metricName => {
                const sortedList = sortByMetric(metricName);
                if (n) sortedList.splice(n); // keep only top N

                let subHtml = `
                <details class="collapsible-subsection" open>
                <summary class="hotspot-section-header">${metricDisplayNames[metricName]}</summary>
            `;

                // Add each hotspot as a row-like item
                sortedList.forEach(item => {
                    subHtml += `
                    <div class="hotspot-item">
                    <span class="hotspot-area">${item.nodeId}</span>
                    <span class="hotspot-value">${item.value.toFixed(2)}</span>
                    </div>
                `;
                });

                subHtml += `
                </details>
            `;

                container.innerHTML += subHtml;
            });
        }

        // ---- Helper: Compute the maximum value for each metric ----
        function computeHotspotMax(metrics) {
            let max = {};
            metricNames.forEach(metric => {
                max[metric] = d3.max(Object.values(metrics).map(d => d[metric]));
            });
            return max;
        }

        // ---- Helper: Adjust Arrow Endpoint ----
        function getAdjustedTarget(d) {
            let dx = d.target.x - d.source.x,
                dy = d.target.y - d.source.y,
                dist = Math.sqrt(dx * dx + dy * dy);
            if (dist === 0) return { x: d.target.x, y: d.target.y };
            return { x: d.target.x - (dx / dist) * d.target.r, y: d.target.y - (dy / dist) * d.target.r };
        }

        // ---- Create Network ----
        function createNetwork(nodes, links) {
            // Use a log scale for edge colors.
            const edgeExtent = d3.extent(links, d => Math.log(d.weight));
            const edgeColor = d3.scaleSequential(d3.interpolateSpectral)
                .domain([edgeExtent[1], edgeExtent[0]]);
            const nodeColor = d3.scaleOrdinal(d3.schemeCategory10);
            const nodeSize = d3.scaleSqrt()
                .domain(d3.extent(nodes, d => d.tradeTotal))
                .range([5, 20]);

            // Create annotation group
            annotationGroup = svg.append("g").attr("class", "annotation-group");

            forceSim = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(150))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(w / 2, h / 2));

            const linkGroup = svg.append("g").attr("class", "links");
            linkSelection = linkGroup.selectAll("path")
                .data(links)
                .enter().append("path")
                .attr("class", "link")
                .attr("stroke", d => edgeColor(Math.log(d.weight)))
                .attr("stroke-width", d => Math.sqrt(d.weight));

            const nodeGroup = svg.append("g").attr("class", "nodes");

            metricNames.forEach(metric => {
                // Sort the keys (node IDs) of hotspots by descending metric value.
                top3ForMetric[metric] = Object.keys(hotspots)
                    .sort((a, b) => hotspots[b][metric] - hotspots[a][metric])
                    .slice(0, 3);
            });

            // Create a group for each node (will contain circle, hotspot strokes, and label)
            nodeEnter = nodeGroup.selectAll(".nodeGroup")
                .data(nodes)
                .enter().append("g")
                .attr("class", "nodeGroup")
                .call(drag(forceSim))
                .on("click", onClickNode)
                .on("mouseover", function (event, d) {
                    hoveredNode = d;
                    d3.select(this).raise();
                    d3.select(this).select("circle.primary")
                        .attr("stroke", "black");

                    updateAnnotationForNode(d, annotationGroup);
                })
                .on("mousemove", function (event, d) {
                    if (hoveredNode === d) {
                        updateAnnotationForNode(d, annotationGroup);
                    }
                })
                .on("mouseout", function (event, d) {
                    hoveredNode = null;
                    d3.select(this).select("circle.primary")
                        .attr("stroke", null)
                        .attr("stroke-width", null);

                    annotationGroup.selectAll("*").remove();

                    // Remove content in #radial-labels-container
                    d3.select("#radial-labels-container").selectAll("*").remove();
                });

            // Append primary node circle.
            nodeEnter.append("circle")
                .attr("class", "primary")
                .attr("r", d => { d.r = nodeSize(d.tradeTotal); return d.r; })
                .attr("fill", d => {
                    let cid = d.community;
                    return nodeColor(cid);
                })
                .attr("stroke", null)
                .attr("stroke-width", null);

            // Append extra hotspot strokes based on top3ForMetric.
            nodeEnter.each(function (d) {
                let metricsForNode = [];
                metricNames.forEach(metric => {
                    // If this node is in the top-3 for the metric, add it.
                    if (top3ForMetric[metric].includes(d.id)) {
                        metricsForNode.push(metric);
                    }
                });
                metricsForNode.sort();
                let group = d3.select(this);
                metricsForNode.forEach((metric, i) => {
                    group.append("circle")
                        .attr("class", "hotspotStroke")
                        .attr("r", d.r + (i + 1) * 3) // each extra ring offset by 3px per metric
                        .attr("fill", "none")
                        .attr("stroke", hotspotColors[metric])
                        .attr("stroke-width", 2)
                        .attr("stroke-dashoffset", 0);
                });
            });

            // Append text labels for nodes.
            labelSelection = nodeGroup.selectAll(".nodeLabel")
                .data(nodes)
                .enter().append("text")
                .attr("class", "nodeLabel")
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .attr("fill", "black")
                .text(d => d.id);

            // Append trade donut visualization for each node.
            nodeEnter.each(function (d) {
                // Compute self trade volume: sum of weights for links where source and target are the same.
                const selfVolume = d3.sum(allLinks.filter(link => {
                    let src = (typeof link.source === "object") ? link.source.id : link.source;
                    let tgt = (typeof link.target === "object") ? link.target.id : link.target;
                    return src === d.id && tgt === d.id;
                }), link => link.weight);

                // Compute external trade volume: sum of weights for links where source is d.id and target is not d.id.
                const otherVolume = d3.sum(allLinks.filter(link => {
                    let src = (typeof link.source === "object") ? link.source.id : link.source;
                    let tgt = (typeof link.target === "object") ? link.target.id : link.target;
                    return src === d.id && tgt !== d.id;
                }), link => link.weight);

                const totalVolume = selfVolume + otherVolume;

                // Only add the donut if there's any trade volume.
                if (totalVolume > 0) {
                    // Define inner and outer radii for the donut relative to the node's radius.
                    const innerRadius = d.r * 0.3;
                    const outerRadius = d.r * 0.8;

                    // Compute the fraction (and angle) of self trade.
                    const selfFraction = selfVolume / totalVolume;
                    const selfAngle = 2 * Math.PI * selfFraction;

                    // Create an arc generator.
                    const arc = d3.arc()
                        .innerRadius(innerRadius)
                        .outerRadius(outerRadius);

                    // Append a new group for the donut; since the node group is already transformed,
                    // this donut will be centered at (0,0) within that group.
                    const donutGroup = d3.select(this)
                        .append("g")
                        .attr("class", "trade-donut")
                        .attr("transform", "translate(0,0)");

                    // Append arc for self trade (e.g., orange).
                    donutGroup.append("path")
                        .attr("d", arc({ startAngle: 0, endAngle: selfAngle }))
                        .attr("fill", "white")
                        .attr("opacity", 0.8);

                    // Append arc for external trade (e.g., blue).
                    donutGroup.append("path")
                        .attr("d", arc({ startAngle: selfAngle, endAngle: 2 * Math.PI }))
                        .attr("fill", "black")
                        .attr("opacity", 0.1);
                }
            });

            forceSim.on("tick", () => {
                if (currentMode === "graph") {
                    linkSelection.attr("d", function (d) {
                        const dx = d.target.x - d.source.x,
                            dy = d.target.y - d.source.y,
                            dr = Math.sqrt(dx * dx + dy * dy),
                            adj = getAdjustedTarget(d);
                        return "M" + d.source.x + "," + d.source.y +
                            "A" + dr + "," + dr + " 0 0,1 " + adj.x + "," + adj.y;
                    });
                    // Update positions of the node groups (circle + hotspot strokes)
                    nodeEnter.attr("transform", d => `translate(${d.x},${d.y})`);
                    // Update text labels positions.
                    labelSelection
                        .attr("x", d => d.x)
                        .attr("y", d => d.y - (d.r + 13));
                    // If a node is hovered, update its annotation.
                    if (hoveredNode) {
                        updateAnnotationForNode(hoveredNode, annotationGroup);
                    }
                    // // If a link is hovered, update its annotation.
                    // if (hoveredLink) {
                    //     updateAnnotationForLink(hoveredLink, annotationGroup);
                    // }
                }
            });

            linkSelection
                .on("mouseover", function (event, d) {
                    hoveredLink = d;
                    if (d3.select(this).classed("linkSelect")) {
                        d3.select(this).attr("class", "linkSelectOver").raise();
                    } else {
                        d3.select(this).attr("class", "linkOver").raise();
                    }
                    updateAnnotationForLink(d, annotationGroup);
                })
                // .on("mousemove", function (event, d) {
                //     if (hoveredLink === d) {
                //         updateAnnotationForLink(d, annotationGroup);
                //     }
                // })
                .on("mouseout", function (event, d) {
                    if (d3.select(this).classed("linkSelectOver")) {
                        d3.select(this).attr("class", "linkSelect");
                    } else {
                        d3.select(this).attr("class", "link");
                    }
                    // Clear annotations.
                    annotationGroup.selectAll("*").remove();
                });

            // ---- Add Hotspot Stroke Legend ----
            addHotspotLegend(svg);

            // ---- Define Edge Glow and Drop Shadow Filters ----
            // Select existing defs or create one if not present.
            let defs = svg.select("defs");
            if (defs.empty()) {
                defs = svg.append("defs");
            }

            // Define the edge glow filter.
            const edgeGlow = defs.append("filter")
                .attr("id", "edgeGlow")
                .attr("x", "-50%")
                .attr("y", "-50%")
                .attr("width", "200%")
                .attr("height", "200%");

            edgeGlow.append("feGaussianBlur")
                .attr("in", "SourceGraphic")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            const feMerge = edgeGlow.append("feMerge");
            feMerge.append("feMergeNode")
                .attr("in", "blur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");
        }

        function updateAnnotationForNode(d, annotationGroup) {
            if (!d) {
                annotationGroup.selectAll("*").remove();
                return;
            }

            // Use fixed coordinates in map mode if available.
            const xPos = (currentMode === "map" && d.x0 !== undefined) ? d.x0 : d.x;
            const yPos = (currentMode === "map" && d.y0 !== undefined) ? d.y0 : d.y;

            const offsets = getAnnotationOffset(xPos, yPos, w, h);

            // --- Compute trade volumes using only enabled links ---
            const incomingTrade = d3.sum(allLinks.filter(link => {
                const tgt = (typeof link.target === "object") ? link.target.id : link.target;
                return tgt === d.id && !link.disabled;
            }), link => link.weight);

            const outgoingTrade = d3.sum(allLinks.filter(link => {
                const src = (typeof link.source === "object") ? link.source.id : link.source;
                return src === d.id && !link.disabled;
            }), link => link.weight);

            const selfTrade = d3.sum(allLinks.filter(link => {
                const src = (typeof link.source === "object") ? link.source.id : link.source;
                const tgt = (typeof link.target === "object") ? link.target.id : link.target;
                return src === d.id && tgt === d.id && !link.disabled;
            }), link => link.weight);

            // Calculate self-trade ratio. If outgoingTrade is zero, default to 0.
            const selfTradeRatio = outgoingTrade > 0 ? ((selfTrade / outgoingTrade) * 100).toFixed(1) : "0.0";

            const noteLabel = `Community ID: ${d.community}\nIncoming Trade: ${incomingTrade}\nOutgoing Trade: ${outgoingTrade}\nSelf-Trade Ratio: ${selfTradeRatio}%`;

            const annotations = [{
                note: {
                    title: `${d.id} ${d.statnaam}`,
                    label: noteLabel,
                    wrapSplitter: /\n/,
                    wrap: 200,
                    bgPadding: { top: 6, left: 6, right: 4, bottom: 4 }
                },
                x: xPos,
                y: yPos,
                dx: offsets.dx,
                dy: offsets.dy
            }];

            const makeAnnotations = d3.annotation()
                .type(nodeAnnoType)
                .notePadding(10)
                .annotations(annotations);

            annotationGroup.call(makeAnnotations).raise();

            // Style the annotation note background.
            annotationGroup.selectAll("rect.annotation-note-bg")
                .attr("fill", selectedNodeData ? "white" : "green")
                .attr("fill-opacity", 0.8)
                .attr("rx", 4)
                .attr("ry", 4);

            // Update connector and note-line colors.
            d3.selectAll(".annotation-connector .connector")
                .attr("stroke", selectedNodeData ? "white" : "green");
            d3.selectAll(".annotation-note .note-line")
                .attr("stroke", selectedNodeData ? "white" : "green");
            d3.selectAll(".annotation text")
                .attr("fill", selectedNodeData ? "gray" : "white");

            // Draw the radar chart inside the annotation.
            const noteContent = annotationGroup.select(".annotation-note-content");
            drawRadarChart(noteContent, offsets, d);

            // Update radial axis labels.
            const radarElem = d3.select("svg.custom-radar").node();
            const bbox = radarElem.getBoundingClientRect();
            const centerX = bbox.x + bbox.width / 2;
            const centerY = bbox.y + bbox.height / 2;

            // Define radar chart dimensions.
            const radarChartWidth = 130;
            const radarChartHeight = 130;
            const radarChartPadding = 20;
            const drawWidth = radarChartWidth - radarChartPadding * 2;
            const drawHeight = radarChartHeight - radarChartPadding * 2;
            const radarRadius = Math.min(drawWidth, drawHeight) / 2 - 10;

            const axisLabels = ["ID", "OD", "BT", "PR", "EC"]; // EC: Eigenvector Centrality.
            drawRadialAxisLabels(centerX, centerY + 5, radarRadius, axisLabels, "#radial-labels-container");
        }

        function drawRadarChart(noteContent, offsets, d) {
            // Remove any existing radar chart.
            noteContent.select("svg.custom-radar").remove();

            // Define dimensions for the radar chart.
            const radarChartWidth = 130;
            const radarChartHeight = 130;
            const radarChartGap = 10;
            const radarChartPadding = 20;

            let radarSVG;
            if (offsets.dy < 0) {
                // Annotation goes upward: place radar chart above the note title.
                const titleElem = noteContent.select(".annotation-note-title").node();
                const bbox = titleElem.getBBox();
                radarSVG = noteContent.insert("svg", ".annotation-note-title")
                    .attr("class", "custom-radar")
                    .attr("width", radarChartWidth)
                    .attr("height", radarChartHeight)
                    .attr("x", 0)
                    .attr("y", bbox.y - radarChartHeight - radarChartGap);
            } else {
                // Annotation goes downward: place radar chart below the note label.
                const labelElem = noteContent.select(".annotation-note-label").node();
                const bbox = labelElem.getBBox();
                radarSVG = noteContent.insert("svg", ".annotation-note-title")
                    .attr("class", "custom-radar")
                    .attr("width", radarChartWidth)
                    .attr("height", radarChartHeight)
                    .attr("x", 0)
                    .attr("y", bbox.y + bbox.height + radarChartGap);
            }

            // Append a background rectangle with padding and rounded corners.
            radarSVG.append("rect")
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", radarChartWidth)
                .attr("height", radarChartHeight)
                .attr("fill", selectedNodeData ? "white" : "green")
                .attr("fill-opacity", 0.8)
                .attr("rx", 4)
                .attr("ry", 4);

            // Define padding for the radar drawing.
            const padding = {
                top: radarChartPadding - 5,
                left: radarChartPadding + 5,
                right: radarChartPadding + 5,
                bottom: radarChartPadding - 10
            };
            const drawWidth = radarChartWidth - padding.left - padding.right;
            const drawHeight = radarChartHeight - padding.top - padding.bottom;

            // Append group for radar drawing.
            const drawingGroup = radarSVG.append("g")
                .attr("class", "radar-drawing")
                .attr("transform", `translate(${padding.left},${padding.top})`);

            // --- Normalize hotspot metrics ---
            // Get the hotspot metrics for the node.
            const nodeMetrics = hotspots[d.id];
            if (!nodeMetrics) return;

            // Log normalization for inDegree and outDegree.
            const normIn = Math.log(nodeMetrics.inDegree + 1) / Math.log(hotspotsMax.inDegree + 1);
            const normOut = Math.log(nodeMetrics.outDegree + 1) / Math.log(hotspotsMax.outDegree + 1);
            const normBet = nodeMetrics.betweenness / hotspotsMax.betweenness;
            const normPR = nodeMetrics.pageRank / hotspotsMax.pageRank;
            const normEigen = nodeMetrics.eigenvector / hotspotsMax.eigenvector;
            const values = [normIn, normOut, normBet, normPR, normEigen];

            // --- Radar chart geometry ---
            const radarRadius = Math.min(drawWidth, drawHeight) / 2 + 3;
            const numAxes = 5;
            const baseAngle = -Math.PI / 2;  // start at the top.
            const centerX = drawWidth / 2;
            const centerY = drawHeight / 2 + 3;

            // Points for the node's radar polygon.
            const points = values.map((val, i) => {
                const angle = baseAngle + (2 * Math.PI * i / numAxes);
                return [
                    radarRadius * val * Math.cos(angle) + centerX,
                    radarRadius * val * Math.sin(angle) + centerY
                ];
            });

            // Baseline points: each axis at maximum value.
            const baselinePoints = [];
            for (let i = 0; i < numAxes; i++) {
                const angle = baseAngle + (2 * Math.PI * i / numAxes);
                baselinePoints.push([
                    radarRadius * 1.0 * Math.cos(angle) + centerX,
                    radarRadius * 1.0 * Math.sin(angle) + centerY
                ]);
            }

            // --- Draw axis lines ---
            for (let i = 0; i < numAxes; i++) {
                const angle = baseAngle + (2 * Math.PI * i / numAxes);
                const x2 = radarRadius * Math.cos(angle) + centerX;
                const y2 = radarRadius * Math.sin(angle) + centerY;
                drawingGroup.append("line")
                    .attr("x1", centerX)
                    .attr("y1", centerY)
                    .attr("x2", x2)
                    .attr("y2", y2)
                    .attr("stroke", selectedNodeData ? "rgba(0,0,0,0.5)" : "rgba(255,255,255,0.5)")
                    .attr("stroke-dasharray", "2,2")
                    .attr("stroke-width", 1);
            }

            // --- Draw baseline radar polygon (maximum values) as a dashed outline.
            const radarLine = d3.line().curve(d3.curveLinearClosed);
            drawingGroup.append("path")
                .attr("d", radarLine(baselinePoints))
                .attr("fill", "none")
                .attr("stroke", selectedNodeData ? "rgba(0,0,0,0.7)" : "rgba(255,255,255,0.7)")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "4,4");

            // --- Draw the node's radar polygon ---
            drawingGroup.append("path")
                .attr("d", radarLine(points))
                .attr("fill", selectedNodeData ? "rgba(0,0,0,0.2)" : "rgba(255,255,255,0.2)")
                .attr("stroke", selectedNodeData ? "rgba(0,0,0,1)" : "rgba(255,255,255,1)")
                .attr("stroke-width", 2);

            // --- Add vertices ---
            drawingGroup.selectAll("circle.vertex")
                .data(points)
                .enter().append("circle")
                .attr("class", "vertex")
                .attr("cx", d => d[0])
                .attr("cy", d => d[1])
                .attr("r", 2)
                .attr("fill", selectedNodeData ? "rgba(0,0,0,1)" : "rgba(255,255,255,1)");
        }

        /**
         * Draws radial axis labels as independent HTML elements.
         * The labels are appended to a container that is taken out of the normal layout flow.
         *
         * @param {number} centerX - X-coordinate of the radar chart center.
         * @param {number} centerY - Y-coordinate of the radar chart center.
         * @param {number} radarRadius - The radar chart radius.
         * @param {Array} labels - Array of five axis label strings.
         * @param {string} containerSelector - Selector for the overlay container.
         */
        function drawRadialAxisLabels(centerX, centerY, radarRadius, labels, containerSelector) {
            // Select or create the overlay container.
            let container = d3.select(containerSelector);
            if (container.empty()) {
                container = d3.select("body").append("div")
                    .attr("id", containerSelector.replace("#", ""))
                    .style("position", "fixed")
                    .style("top", "0px")
                    .style("left", "0px")
                    .style("width", "100%")
                    .style("height", "100%")
                    .style("pointer-events", "none")
                    .style("z-index", "9999");
            }

            // Clear any previous labels.
            container.selectAll(".radial-axis-label").remove();

            // Base angle: start at the top.
            const baseAngle = -Math.PI / 2;
            // Define offset (in pixels) beyond the radar radius.
            const offset = 20;

            // For each label, compute its absolute (viewport) position.
            labels.forEach((label, i) => {
                const angle = baseAngle + (2 * Math.PI * i / labels.length);
                // Compute position relative to the provided center and radius.
                const x = centerX + (radarRadius + offset) * Math.cos(angle);
                const y = centerY + (radarRadius + offset) * Math.sin(angle);

                // Append an independent label element.
                container.append("div")
                    .attr("class", "radial-axis-label")
                    .style("position", "fixed")
                    .style("left", `${x}px`)
                    .style("top", `${y}px`)
                    .style("transform", "translate(-50%, -50%)")
                    .style("background", "rgba(0, 0, 0, 0)")
                    .style("color", selectedNodeData ? "gray" : "white")
                    .style("padding", "2px 4px")
                    .style("border-radius", "3px")
                    .style("font-size", "10px")
                    .style("pointer-events", "none")
                    .text(label);
            });
        }

        function updateAnnotationForLink(d, annotationGroup) {
            // Determine source and target coordinates:
            let sx, sy, tx, ty;
            if (currentMode === "map" &&
                d.x0 !== undefined && d.y0 !== undefined &&
                d.x1 !== undefined && d.y1 !== undefined) {
                // Use fixed coordinates when in map mode.
                sx = d.x0;
                sy = d.y0;
                tx = d.x1;
                ty = d.y1;
            } else {
                // Use dynamic positions.
                sx = (typeof d.source === "object") ? d.source.x : d.source;
                sy = (typeof d.source === "object") ? d.source.y : d.source;
                const adj = getAdjustedTarget(d);
                tx = adj.x;
                ty = adj.y;
            }

            // Compute the chord midpoint.
            const midChordX = (sx + tx) / 2;
            const midChordY = (sy + ty) / 2;

            // Compute chord vector and its length.
            const dx = tx - sx;
            const dy = ty - sy;
            const L = Math.sqrt(dx * dx + dy * dy);
            if (L === 0) return;  // avoid division by zero

            // For an arc drawn as "A L,L,0,0,1,..." the subtended angle is 60° (π/3).
            // The distance from the chord midpoint to the arc midpoint is:
            // arcOffset = L * (1 - cos(θ/2))
            const thetaOver2 = Math.asin(0.5); // 30° in radians.
            const arcOffset = L * (1 - Math.cos(thetaOver2));

            // Compute a unit perpendicular vector to the chord (using -dy, dx).
            const ux = -dy / L,
                uy = dx / L;

            // Compute the arc midpoint by offsetting the chord midpoint by arcOffset along the perpendicular.
            const midX = midChordX - ux * arcOffset;
            const midY = midChordY - uy * arcOffset;

            const offsets = getAnnotationOffsetNoXDefault(midX, midY, w, h);

            const titleStringSource = getStatnaam(d.source.id);
            const titleStringTarget = getStatnaam(d.target.id);
            const annotations = [{
                note: {
                    title: `${titleStringSource} → ${titleStringTarget}`,
                    label: `Trade volume: ${d.weight}`,
                    wrapSplitter: /\n/,
                    wrap: 0.5 * w - 60,
                    bgPadding: { top: 6, left: 6, right: 4, bottom: 4 }
                },
                x: midX,
                y: midY,
                dx: offsets.dx,
                dy: offsets.dy
            }];

            const makeAnnotations = d3.annotation()
                .type(linkAnnoType)
                .notePadding(10)
                .annotations(annotations);

            annotationGroup.call(makeAnnotations).raise();
            annotationGroup.selectAll("rect.annotation-note-bg")
                .attr("fill", selectedNodeData ? "white" : "green")
                .attr("fill-opacity", 0.8)
                .attr("rx", 4)
                .attr("ry", 4);
            d3.selectAll(".annotation-connector .connector")
                .attr("stroke", selectedNodeData ? "white" : "green")
            d3.selectAll(".annotation-note .note-line")
                .attr("stroke", selectedNodeData ? "white" : "green");
            d3.selectAll(".annotation text")
                .attr("fill", selectedNodeData ? "gray" : "white");
        }

        // Helper function: Adjust dx, dy based on node position relative to SVG bounds.
        function getAnnotationOffset(x, y, svgWidth, svgHeight) {
            let dx = 50;  // default offset
            let dy = -50; // default offset above the node

            // Horizontal adjustment:
            if (x < svgWidth * 0.3) {
                // Node is near left edge: place annotation to the right.
                dx = 50;
            } else if (x > svgWidth * 0.7) {
                // Node is near right edge: place annotation to the left.
                dx = -50;
            } else {
                dx = 0; // Centered horizontally.
            }

            // Vertical adjustment:
            if (y < svgHeight * 0.4) {
                // Node is near top edge: place annotation below.
                dy = 50;
            } else if (y > svgHeight * 0.6) {
                // Node is near bottom edge: place annotation above.
                dy = -50;
            } else {
                dy = -50; // default above node.
            }

            return { dx, dy };
        }

        function getAnnotationOffsetNoXDefault(x, y, svgWidth, svgHeight) {
            // Horizontal offset: if x is more than half the width, place annotation to the left (-50); otherwise, to the right (+50).
            const dx = (x > svgWidth / 2) ? -50 : 50;

            let dy;
            if (y < svgHeight * 0.3) {
                // Near the top edge: shift annotation downward.
                dy = 50;
            } else if (y > svgHeight * 0.7) {
                // Near the bottom edge: shift annotation upward.
                dy = -50;
            } else {
                // Default: place annotation above the point.
                dy = -50;
            }

            return { dx, dy };
        }

        function addHotspotLegend(svg) {
            const legendWidth = w / 3;
            const margin = { top: 50, right: 50, bottom: 50, left: 50 };

            const legendData = [
                { name: "Vulnerable", color: hotspotColors.inDegree },
                { name: "Seeding", color: hotspotColors.outDegree },
                { name: "Bottleneck", color: hotspotColors.betweenness },
                { name: "Sink", color: hotspotColors.pageRank },
                { name: "Amplifier", color: hotspotColors.eigenvector }
            ];

            const legend = svg.append("g")
                .attr("class", "hotspotLegend")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);

            const legendItem = legend.selectAll(".legendItem")
                .data(legendData)
                .enter().append("g")
                .attr("class", "legendItem")
                .attr("transform", (d, i) => `translate(${margin.left}, ${margin.top + i * 25})`);

            legendItem.append("circle")
                .attr("r", 8)
                .attr("fill", "none")
                .attr("stroke", d => d.color)
                .attr("stroke-width", 2.5)
                .attr("stroke-dasharray", "5 5")
                .attr("stroke-dashoffset", 0);

            legendItem.append("text")
                .attr("x", 25)
                .attr("y", 7)
                .attr("font-size", "15px")
                .attr("fill", "black")
                .text(d => d.name);

            // Append a "?" button below the legend items.
            legend.append("foreignObject")
                .attr("class", "hotspot-info-button")
                .attr("x", margin.left - 10)  // Position it below the legend
                .attr("y", margin.top + legendData.length * 25 - 5)
                .attr("width", 30)
                .attr("height", 30)
                .html('<i class="fas fa-circle-question"></i>')  // FontAwesome icon
                .style("font-size", "22px")
                .style("color", "green")
                .style("cursor", "pointer")
                .on("click", function () {
                    showHotspotInfoOverlay();  // Function to display the overlay
                })
                .on("mouseover", function () {
                    d3.select(this).style("transform", "scale(1.1)").style("filter", "brightness(1.2)");
                })
                .on("mouseout", function () {
                    d3.select(this).style("transform", "scale(1)").style("filter", "brightness(1)");
                });
        }

        function showHotspotInfoOverlay() {
            // Create or select the overlay container.
            let overlay = d3.select("body").select("#hotspotInfoOverlay");
            if (overlay.empty()) {
                overlay = d3.select("body").append("div")
                    .attr("id", "hotspotInfoOverlay")
                    .style("position", "fixed")
                    .style("top", "0")
                    .style("left", "0")
                    .style("width", "100%")
                    .style("height", "100%")
                    .style("background", "rgba(0,0,0,0.6)")
                    .style("display", "flex")
                    .style("justify-content", "center")
                    .style("align-items", "center")
                    .style("z-index", "10000")
                    .style("pointer-events", "auto");
            }

            // Clear any previous content.
            overlay.html("");

            // Create a card container.
            const card = overlay.append("div")
                .attr("class", "hotspot-info-card")
                .style("background", "#fff")
                .style("padding", "20px")
                .style("border-radius", "8px")
                .style("max-width", "800px")
                .style("width", "80%")
                .style("box-shadow", "0 2px 8px rgba(0,0,0,0.3)")
                .style("font-family", "sans-serif")
                .style("color", "#333")
                .style("position", "relative");

            // Add a close button.
            card.append("div")
                .attr("class", "hotspot-info-close")
                .style("position", "absolute")
                .style("top", "10px")
                .style("right", "10px")
                .style("cursor", "pointer")
                .style("font-size", "18px")
                .html('<i class="fa-solid fa-circle-xmark"></i>')
                .on("click", function () {
                    overlay.transition()
                        .duration(300)
                        .style("opacity", 0)
                        .on("end", () => overlay.remove());
                });

            // Add a title.
            card.append("h2")
                .style("margin-top", "0")
                .text("Hotspot Metrics Overview");

            // Create a table.
            const tableHTML = `
                <table style="width:100%; border-collapse: collapse; font-size: 14px;">
                <thead>
                    <tr style="background: #4CAF50; color: white;">
                    <th style="padding: 8px; border: 1px solid #ddd;">Code</th>
                    <th style="padding: 8px; border: 1px solid #ddd;">Metric</th>
                    <th style="padding: 8px; border: 1px solid #ddd;">Descriptor</th>
                    <th style="padding: 8px; border: 1px solid #ddd;">Interpretation</th>
                    <th style="padding: 8px; border: 1px solid #ddd;">Calculation</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                    <td style="padding: 8px; border: 1px solid #ddd;">ID</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Weighted In-Degree</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Vulnerable</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Farms frequently receiving livestock (high exposure risk).</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Sum of incoming trade weights (log-scaled).</td>
                    </tr>
                    <tr>
                    <td style="padding: 8px; border: 1px solid #ddd;">OD</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Weighted Out-Degree</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Seeding</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Farms frequently sending livestock (potential spreaders).</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Sum of outgoing trade weights (log-scaled).</td>
                    </tr>
                    <tr>
                    <td style="padding: 8px; border: 1px solid #ddd;">BT</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Betweenness</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Bottleneck</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Farms acting as bridges; their disruption can hinder spread.</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Computed via Brandes algorithm (shortest-path based).</td>
                    </tr>
                    <tr>
                    <td style="padding: 8px; border: 1px solid #ddd;">PR</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">PageRank</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Sink</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Farms that often receive livestock from key hubs.</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Iterative random-walk based model.</td>
                    </tr>
                    <tr>
                    <td style="padding: 8px; border: 1px solid #ddd;">EC</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Eigenvector Centrality</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Amplifier</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Farms connected to influential nodes, potentially magnifying outbreaks.</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">Computed via power iteration on the adjacency matrix.</td>
                    </tr>
                </tbody>
                </table>
            `;
            card.append("div").html(tableHTML);

            overlay.style("opacity", 0)
                .transition().duration(300)
                .style("opacity", 1);
        }


        // ---- Node Click Handler ----
        function onClickNode(event, d) {
            if (event.defaultPrevented) return;
            // Save previous selection before clearing
            let wasSelected = !!selectedNodeData;
            let wasSameNode = selectedNodeData && selectedNodeData.id === d.id;
            // If clicking the same node, clear selection and return.
            if (wasSameNode) {
                clearSelection(false);
                return;
            }
            clearSelection(wasSelected && !wasSameNode);
            selectedNodeData = d;

            updateAnnotationForNode(d, annotationGroup);

            // If clicked, change all node labels to white
            labelSelection.attr("fill", "white");
            // Then update node label styling for the selected node.
            labelSelection.filter(nd => nd.id === d.id)
                .attr("fill", "white")
                .attr("font-weight", "bold")
                .attr("font-size", "21px")
                .attr("filter", "url(#edgeGlow)")
                .attr("stroke", "black")
                .attr("stroke-opacity", 0.8);
            // If clicked, change legend text to white
            d3.selectAll(".legendItem text").attr("fill", "white");
            // If clicked, add glowing filter to legend circles
            d3.selectAll(".legendItem circle").attr("filter", "url(#edgeGlow)");
            // If clicked, add glowing filter to main figure's hotspot strokes
            d3.selectAll(".hotspotStroke").attr("filter", "url(#edgeGlow)");
            // If clicked, change "?" button color to white
            d3.select(".hotspot-info-button").style("color", "white");

            // If clicked, change restore and screenshot buttons to white and their text to black
            d3.select(".restore-button").style("color", "gray");
            d3.select(".screenshot-button").style("color", "gray");
            d3.select(".restore-button").style("background", "white");
            d3.select(".screenshot-button").style("background", "white");

            // If clicked, change spectral radius display background to white and text to black
            d3.select(".spectral-radius-display").style("background", "white");
            d3.select(".spectral-radius-display").style("color", "gray");

            // If clicked, change link colors, add arrowheads and glowing filter
            linkSelection.attr("display", function (linkData) {
                const srcId = (typeof linkData.source === "object" ? linkData.source.id : linkData.source),
                    tgtId = (typeof linkData.target === "object" ? linkData.target.id : linkData.target);
                // Only highlight if the link is connected to the clicked node AND not disabled.
                if (srcId === d.id && !linkData.disabled) {
                    d3.select(this)
                        .attr("class", "linkSelect")
                        .attr("stroke", "#46fa46")
                        .attr("stroke-width", Math.sqrt(linkData.weight) + 2)
                        .attr("opacity", 1)
                        .attr("filter", "url(#edgeGlow)");
                    return "block";
                } else if (tgtId === d.id && !linkData.disabled) {
                    d3.select(this)
                        .attr("class", "linkSelect")
                        .attr("stroke", "#fcc67e")
                        .attr("stroke-width", Math.sqrt(linkData.weight) + 2)
                        .attr("opacity", 1)
                        .attr("filter", "url(#edgeGlow)");
                    return "block";
                } else {
                    return "none";
                }
            })
                .attr("marker-end", function (linkData) {
                    const srcId = (typeof linkData.source === "object" ? linkData.source.id : linkData.source),
                        tgtId = (typeof linkData.target === "object" ? linkData.target.id : linkData.target);
                    if ((srcId === d.id || tgtId === d.id) && !linkData.disabled) {
                        return "url(#arrow)";
                    } else {
                        return null;
                    }
                });


            // Show/Update trade table and (re)-plot in/out arborescences
            updateTradeTable(d);
            replotInOutArbos(d.id);

            // Add an overlay to gray out the background map.
            // Insert a rectangle as the first child of the SVG.
            // Add/update overlay.
            if (svg.select("#mapOverlay").empty()) {
                if (wasSelected) {
                    // If a node was already selected, do NOT animate.
                    svg.insert("rect", ":first-child")
                        .attr("id", "mapOverlay")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("width", w)
                        .attr("height", h)
                        .attr("fill", "black")
                        .attr("opacity", 0.7);
                } else {
                    // If no node was previously selected, animate the overlay.
                    svg.insert("rect", ":first-child")
                        .attr("id", "mapOverlay")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("width", w)
                        .attr("height", h)
                        .attr("fill", "black")
                        .attr("opacity", 0)
                        .transition()
                        .duration(300)
                        .attr("opacity", 0.7);
                }
            }
            // Unhide the trade information panel
            document.getElementById("tradeInfo").style.display = "block";

            // Switch university logo to white version
            document.querySelector('.watermark-logo').src = 'assets/files/herdlink/WUR_W_standard_2021.svg';
        }

        // ---- Clear Selection (If Clicking Again/Unclicked) ----
        function clearSelection(flag) {
            selectedNodeData = null;

            const colorScale = d3.scaleSequential(d3.interpolateSpectral)
                .domain(d3.extent(allLinks, d => Math.log(d.weight)).reverse()); // Inverted color scale

            // Restore node labels: reset fill, font-weight, and font-size.
            labelSelection
                .attr("font-weight", "normal")
                .attr("font-size", "12px")
                .attr("filter", null)
                .attr("stroke", null)
                .attr("stroke-opacity", null);

            // If unclicked, change all node labels back to black
            labelSelection.attr("fill", "black");
            // If unclicked, change legend text back to black
            d3.selectAll(".legendItem text").attr("fill", "black");
            // If unclicked, remove glowing filter from legend circles
            d3.selectAll(".legendItem circle").attr("filter", null);
            // If unclicked, remove glowing filter from main figure's hotspot strokes
            d3.selectAll(".hotspotStroke").attr("filter", null);
            // If unclicked, change "?" button color back to green
            d3.select(".hotspot-info-button").style("color", "green");

            // If unclicked, remove annotation by passing d=null
            updateAnnotationForNode(null, annotationGroup);

            // If unclicked, change restore and screenshot buttons back to green and their text to white
            d3.select(".restore-button").style("color", "white");
            d3.select(".screenshot-button").style("color", "white");
            d3.select(".restore-button").style("background", "linear-gradient(135deg, #4CAF50, #1b872b)");
            d3.select(".screenshot-button").style("background", "linear-gradient(135deg, #4CAF50, #1b872b)");

            // If unclicked, change spectral radius display background to green and text to white
            d3.select(".spectral-radius-display").style("background", "linear-gradient(135deg, #4CAF50, #1b872b)");
            d3.select(".spectral-radius-display").style("color", "white");

            // If unclicked, change link colors back, remove arrowheads and glowing filter
            linkSelection.attr("display", "block")
                .attr("class", "link")
                .attr("marker-end", null)
                .attr("stroke", d => colorScale(Math.log(d.weight))) // Use the inverted scale
                .attr("stroke-width", d => Math.sqrt(d.weight))
                .attr("opacity", 0.5)
                .attr("filter", null);

            // Clear the trade table and arborescences
            updateTradeTable(null);
            replotInOutArbos(null);

            // Hide the trade information panel
            document.getElementById("tradeInfo").style.display = "none";

            // Remove the background overlay if select another node
            if (!flag) {
                svg.select("#mapOverlay").transition().duration(300).attr("opacity", 0).remove();
            } else {
                svg.select("#mapOverlay").remove();
            }

            // Call the updateNetwork function to reset the network with instant=true
            updateNetwork(instant = true);

            // Switch the university logo back to the black version
            document.querySelector('.watermark-logo').src = 'assets/files/herdlink/WUR_ZW_standard_2021.svg';
        }

        function updateTradeTable(selectedNode) {
            const tradePanelDiv = document.getElementById("tradePanel");
            if (!selectedNode) {
                tradePanelDiv.innerHTML = "";
                return;
            }

            // Filter outgoing and incoming links for the focal node.
            const outgoing = allLinks.filter(d =>
                (typeof d.source === "object" ? d.source.id : d.source) === selectedNode.id
            );
            const incoming = allLinks.filter(d =>
                (typeof d.target === "object" ? d.target.id : d.target) === selectedNode.id
            );

            // Sort descending by weight.
            outgoing.sort((a, b) => b.weight - a.weight);
            incoming.sort((a, b) => b.weight - a.weight);

            // For each section, determine if all trades are enabled.
            const allOutgoingEnabled = outgoing.every(trade => !trade.disabled);
            const allIncomingEnabled = incoming.every(trade => !trade.disabled);

            let html = `
                <div class="trade-info-header">
                <h4><i class="fa-solid fa-location-dot"></i> ${selectedNode.statnaam} [${selectedNode.id}] </h4>
                </div>
                <div class="trade-sections d-flex gap-3">
                <!-- Outgoing trades section -->
                <div class="trade-section flex-fill">
                    <div class="trade-section-header">
                    <i class="fa-solid fa-arrow-right-from-bracket"></i> Outgoing Trades
                    <input type="checkbox" class="trade-header-checkbox" data-section="outgoing" ${allOutgoingEnabled ? "checked" : ""}>
                    </div>
                    <div class="trade-list" style="max-height: 17vh; overflow-y: auto;">`;

            if (outgoing.length > 0) {
                outgoing.forEach(trade => {
                    const dest = getStatnaam((typeof trade.target === "object" ? trade.target.id : trade.target));
                    let s = (typeof trade.source === "object") ? trade.source.id : trade.source;
                    let t = (typeof trade.target === "object") ? trade.target.id : trade.target;
                    html += `
                    <div class="trade-item d-flex align-items-center">
                        <div class="flex-grow-1 d-flex justify-content-between">
                            <span class="trade-dest">${dest}</span>
                            <span class="trade-volume">${trade.weight}</span>
                        </div>
                        <input type="checkbox" class="trade-checkbox" data-section="outgoing" data-source="${s}" data-target="${t}" ${!trade.disabled ? "checked" : ""}>
                    </div>
                `;
                });
            } else {
                html += `<div class="trade-item no-trades">No outgoing trades.</div>`;
            }

            html += `
                    </div> <!-- .trade-list -->
                </div> <!-- .trade-section -->

                <!-- Incoming trades section -->
                <div class="trade-section flex-fill">
                    <div class="trade-section-header">
                    <i class="fa-solid fa-arrow-right-to-bracket"></i> Incoming Trades
                    <input type="checkbox" class="trade-header-checkbox" data-section="incoming" ${allIncomingEnabled ? "checked" : ""}>
                    </div>
                    <div class="trade-list" style="max-height: 17vh; overflow-y: auto;">`;

            if (incoming.length > 0) {
                incoming.forEach(trade => {
                    const src = getStatnaam((typeof trade.source === "object" ? trade.source.id : trade.source));
                    let s = (typeof trade.source === "object") ? trade.source.id : trade.source;
                    let t = (typeof trade.target === "object") ? trade.target.id : trade.target;
                    html += `
                            <div class="trade-item d-flex align-items-center">
                                <div class="flex-grow-1 d-flex justify-content-between">
                                    <span class="trade-src">${src}</span>
                                    <span class="trade-volume">${trade.weight}</span>
                                </div>
                                <input type="checkbox" class="trade-checkbox" data-section="incoming" data-source="${s}" data-target="${t}" ${!trade.disabled ? "checked" : ""}>
                            </div>
                            `;
                });
            } else {
                html += `<div class="trade-item no-trades">No incoming trades.</div>`;
            }

            html += `
                    </div> <!-- .trade-list -->
                </div> <!-- .trade-section -->
                </div> <!-- .trade-sections -->
            `;

            tradePanelDiv.innerHTML = html;
            attachTradeCheckboxListeners();
        }

        function attachTradeCheckboxListeners() {
            // Header checkboxes toggle all trade checkboxes in that section.
            d3.selectAll('.trade-header-checkbox').on('change', function () {
                const section = this.dataset.section;  // "outgoing" or "incoming"
                const checked = this.checked;
                // Toggle all individual checkboxes for that section.
                d3.selectAll(`.trade-checkbox[data-section='${section}']`)
                    .property('checked', checked);

                // For self-loops, update all self-loop checkboxes across both sections.
                d3.selectAll('.trade-checkbox')
                    .filter(function () {
                        return this.dataset.source === this.dataset.target;
                    })
                    .property('checked', checked);

                updateNetwork();
                updateDonutCharts();
                updateSpectralRadiusDisplay();
                updateNetworkStats(allNodes, allLinks);
                replotInOutArbos(selectedNodeData ? selectedNodeData.id : null);
                hotspots = computeHotSpotMetrics(allNodes, allLinks);
                hotspotsMax = computeHotspotMax(hotspots);
                console.log(hotspotsMax);
                printHotSpots(hotspots, "topMetrics", 3);
                replotHotspots();
                const newsccs = findSCCs(allNodes, allLinks);
                displaySCCsInCards(newsccs, "sccOutput");

                // Update header checkbox state based on the current state of individuals.
                updateHeaderCheckboxes();
            });

            // Individual trade checkbox changes trigger a network update.
            d3.selectAll('.trade-checkbox').on('change', function () {
                const checkbox = this;
                const source = checkbox.dataset.source;
                const target = checkbox.dataset.target;
                const isEnabled = checkbox.checked;
                // If it's a self-loop (source equals target), update all self-loop checkboxes across both sections.
                if (source === target) {
                    d3.selectAll('.trade-checkbox')
                        .filter(function () {
                            return this.dataset.source === source && this.dataset.target === target;
                        })
                        .property('checked', isEnabled);
                }
                updateNetwork();
                updateDonutCharts();
                updateSpectralRadiusDisplay();
                updateNetworkStats(allNodes, allLinks);
                replotInOutArbos(selectedNodeData ? selectedNodeData.id : null);
                hotspots = computeHotSpotMetrics(allNodes, allLinks);
                hotspotsMax = computeHotspotMax(hotspots);
                printHotSpots(hotspots, "topMetrics", 3);
                replotHotspots();
                const newsccs = findSCCs(allNodes, allLinks);
                displaySCCsInCards(newsccs, "sccOutput");

                // Update header checkbox state for both sections.
                updateHeaderCheckboxes();
            });
        }

        // Helper function to update header checkbox states.
        function updateHeaderCheckboxes() {
            ['incoming', 'outgoing'].forEach(section => {
                // Select all individual checkboxes for the section.
                const checkboxes = d3.selectAll(`.trade-checkbox[data-section='${section}']`).nodes();
                // If every individual checkbox is checked, then the header is checked.
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                d3.select(`.trade-header-checkbox[data-section='${section}']`)
                    .property('checked', allChecked);
            });
        }

        function updateNetwork(instant = false) {
            // Disable buttons during transitions.
            d3.select("#toggleModeButton").attr("disabled", true);
            d3.select("#screenshotButton").attr("disabled", true);

            // 1. Update link.disabled based on checkboxes.
            d3.selectAll('.trade-checkbox').each(function () {
                const checkbox = this;
                const source = checkbox.dataset.source;
                const target = checkbox.dataset.target;
                const isEnabled = checkbox.checked;
                allLinks.forEach(link => {
                    let s = (typeof link.source === "object") ? link.source.id : link.source;
                    let t = (typeof link.target === "object") ? link.target.id : link.target;
                    if (s === source && t === target) {
                        link.disabled = !isEnabled;
                    }
                });
            });

            // 2. Update link attributes.
            if (selectedNodeData) {
                // When a node is selected: highlight only links connected to that node and enabled.
                linkSelection.each(function (d) {
                    const srcId = (typeof d.source === "object") ? d.source.id : d.source;
                    const tgtId = (typeof d.target === "object") ? d.target.id : d.target;
                    const relevant = (srcId === selectedNodeData.id || tgtId === selectedNodeData.id);

                    if (d.disabled || !relevant) {
                        if (instant) {
                            d3.select(this)
                                .attr("opacity", 0)
                                .attr("display", "none")
                                .attr("class", "link")
                                .attr("filter", null)
                                .attr("marker-end", null);
                        } else {
                            d3.select(this)
                                .interrupt()
                                .transition().duration(500)
                                .attr("opacity", 0)
                                .on("end", function () {
                                    d3.select(this)
                                        .attr("display", "none")
                                        .attr("class", "link")
                                        .attr("filter", null)
                                        .attr("marker-end", null);
                                });
                        }
                    } else {
                        const isOutgoing = (srcId === selectedNodeData.id);
                        let color = isOutgoing ? "#46fa46" : "#fcc67e";
                        if (instant) {
                            d3.select(this)
                                .attr("display", "block")
                                .attr("opacity", 1)
                                .attr("class", "linkSelect")
                                .attr("stroke", color)
                                .attr("stroke-width", Math.sqrt(d.weight) + 2)
                                .attr("filter", "url(#edgeGlow)")
                                .attr("marker-end", "url(#arrow)");
                        } else {
                            d3.select(this)
                                .interrupt()
                                .attr("display", "block")
                                .transition().duration(500)
                                .attr("opacity", 1)
                                .on("start", function () {
                                    d3.select(this)
                                        .attr("class", "linkSelect")
                                        .attr("stroke", color)
                                        .attr("stroke-width", Math.sqrt(d.weight) + 2)
                                        .attr("filter", "url(#edgeGlow)")
                                        .attr("marker-end", "url(#arrow)");
                                });
                        }
                    }
                });
            } else {
                // When no node is selected: iterate over all links and show only enabled links.
                const edgeExtent = d3.extent(allLinks, d => Math.log(d.weight));
                const edgeColor = d3.scaleSequential(d3.interpolateSpectral)
                    .domain([edgeExtent[1], edgeExtent[0]]);
                linkSelection.each(function (d) {
                    if (d.disabled) {
                        if (instant) {
                            d3.select(this)
                                .attr("opacity", 0)
                                .attr("display", "none")
                                .attr("class", "link")
                                .attr("filter", null)
                                .attr("marker-end", null);
                        } else {
                            d3.select(this)
                                .interrupt()
                                .transition().duration(500)
                                .attr("opacity", 0)
                                .on("end", function () {
                                    d3.select(this)
                                        .attr("display", "none")
                                        .attr("class", "link")
                                        .attr("filter", null)
                                        .attr("marker-end", null);
                                });
                        }
                    } else {
                        if (instant) {
                            d3.select(this)
                                .attr("display", "block")
                                .attr("opacity", 0.5)
                                .attr("class", "link")
                                .attr("stroke", edgeColor(Math.log(d.weight)))
                                .attr("stroke-width", Math.sqrt(d.weight))
                                .attr("filter", null)
                                .attr("marker-end", null);
                        } else {
                            d3.select(this)
                                .interrupt()
                                .attr("display", "block")
                                .transition().duration(500)
                                .attr("opacity", 0.5)
                                .on("start", function (d) {
                                    d3.select(this)
                                        .attr("class", "link")
                                        .attr("stroke", edgeColor(Math.log(d.weight)))
                                        .attr("stroke-width", Math.sqrt(d.weight))
                                        .attr("filter", null)
                                        .attr("marker-end", null);
                                });
                        }
                    }
                });
            }

            // 3. Update node/label positions only if in "graph" mode.
            if (currentMode === "graph") {
                if (instant) {
                    nodeEnter.attr("transform", d => `translate(${d.x},${d.y})`);
                    labelSelection
                        .attr("x", d => d.x)
                        .attr("y", d => d.y - (d.r + 13));
                } else {
                    nodeEnter.transition().duration(500)
                        .attr("transform", d => `translate(${d.x},${d.y})`);
                    labelSelection.transition().duration(500)
                        .attr("x", d => d.x)
                        .attr("y", d => d.y - (d.r + 13));
                }
            }

            // Re-enable the toggle and screenshot buttons after transitions are done.
            if (instant) {
                d3.select("#toggleModeButton").attr("disabled", null);
                d3.select("#screenshotButton").attr("disabled", null);
            } else {
                d3.timeout(() => {
                    d3.select("#toggleModeButton").attr("disabled", null);
                    d3.select("#screenshotButton").attr("disabled", null);
                }, 550);
            }
        }

        function updateDonutCharts() {
            // For each node group (each node)
            d3.selectAll(".nodeGroup").each(function (d) {
                // Filter enabled links that involve this node.
                const enabledLinks = allLinks.filter(link => {
                    const src = (typeof link.source === "object") ? link.source.id : link.source;
                    const tgt = (typeof link.target === "object") ? link.target.id : link.target;
                    // For this donut chart, consider outgoing trades for external volume
                    // and self-loops for self trade.
                    return !link.disabled && src === d.id;
                });

                // Compute self trade volume: links where target is the same as the source.
                const selfVolume = d3.sum(enabledLinks.filter(link => {
                    const tgt = (typeof link.target === "object") ? link.target.id : link.target;
                    return tgt === d.id;
                }), link => link.weight);

                // Compute external trade volume: links where target is different.
                const otherVolume = d3.sum(enabledLinks.filter(link => {
                    const tgt = (typeof link.target === "object") ? link.target.id : link.target;
                    return tgt !== d.id;
                }), link => link.weight);

                const totalVolume = selfVolume + otherVolume;

                // Select (or create) a group for the donut chart inside the node group.
                let donutGroup = d3.select(this).select("g.trade-donut");

                donutGroup.remove();
                donutGroup = d3.select(this)
                    .append("g")
                    .attr("class", "trade-donut")
                    .attr("transform", "translate(0,0)");
                // Append two paths for the two segments.
                donutGroup.append("path").attr("class", "donut-self");
                donutGroup.append("path").attr("class", "donut-other");

                // Define radii for the donut relative to the node's radius.
                const innerRadius = d.r * 0.3;
                const outerRadius = d.r * 0.8;

                // Compute fraction of self-trade.
                const selfFraction = selfVolume / totalVolume;
                const selfAngle = 2 * Math.PI * selfFraction;

                // Create an arc generator.
                const arc = d3.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(outerRadius);

                // Update self-trade arc with white fill.
                donutGroup.select(".donut-self")
                    .attr("d", arc({ startAngle: 0, endAngle: selfAngle }))
                    .attr("fill", "white")
                    .attr("opacity", 0.8);

                // Update external trade arc with black fill.
                donutGroup.select(".donut-other")
                    .attr("d", arc({ startAngle: selfAngle, endAngle: 2 * Math.PI }))
                    .attr("fill", "black")
                    .attr("opacity", 0.1);
            });
        }

        // Function to update the current spectral radius display
        function updateSpectralRadiusDisplay() {
            // Compute the current spectral radius based on enabled links.
            const currentSR = computeSpectralRadius(allNodes, allLinks);

            // Normalize current spectral radius relative to the initial one.
            const normalizedValue = currentSR / initialSpectralRadius; // 1.0 means no change
            // To three decimal places
            const formattedNormal = normalizedValue.toFixed(3);

            // Create a linear color scale:
            // 0.0 maps to avocado green, 1.0 maps to salmon, 2.0 maps to orange.
            const colorScale = d3.scaleLinear()
                .domain([0, 1, 2])
                .range(["#b2c248", "salmon", "orange"])
                .clamp(true);

            // Update the display element.
            const displayElement = document.getElementById("spectralRadiusDisplay");
            displayElement.innerHTML = `
                <i class="fa-solid fa-virus"></i> Risk Score: <span class="current-sr">${formattedNormal}</span> <span class="initial-sr">(1.000)</span>
            `;

            // Set the initial color to always red
            const initialSpan = displayElement.querySelector(".initial-sr");
            initialSpan.style.color = "salmon";

            // Set the color of the current value based on its normalized value.
            const currentSpan = displayElement.querySelector(".current-sr");
            currentSpan.style.color = colorScale(normalizedValue);
        }


        function replotHotspots() {
            metricNames.forEach(metric => {
                // Sort the keys (node IDs) of hotspots by descending metric value.
                top3ForMetric[metric] = Object.keys(hotspots)
                    .sort((a, b) => hotspots[b][metric] - hotspots[a][metric])
                    .slice(0, 3);
            });
            // Use all node groups, not only the initial enter selection.
            d3.selectAll(".nodeGroup").each(function (d) {
                let group = d3.select(this);

                // Compute the updated list of metrics (hotspots) for this node.
                let newMetrics = [];
                metricNames.forEach(metric => {
                    if (top3ForMetric[metric].includes(d.id)) {
                        newMetrics.push(metric);
                    }
                });
                newMetrics.sort(); // ensure consistent order

                // Bind newMetrics to the existing hotspot stroke circles.
                let strokes = group.selectAll("circle.hotspotStroke")
                    .data(newMetrics, m => m); // key is the metric

                // Remove any strokes that are no longer needed.
                strokes.exit()
                    .transition().duration(500)
                    .attr("r", d.r)      // shrink back to the node's radius
                    .style("opacity", 0)
                    .remove();

                // Update existing strokes: adjust radius and stroke color.
                strokes.transition().duration(500)
                    .attr("r", (m, i) => d.r + (i + 1) * 3)
                    .attr("stroke", m => hotspotColors[m]);

                // Append new strokes for any newly added metrics.
                strokes.enter().append("circle")
                    .attr("class", "hotspotStroke")
                    .attr("data-metric", m => m)
                    .attr("fill", "none")
                    .attr("stroke-width", 2)
                    .attr("stroke-dashoffset", 0)
                    .attr("stroke", m => hotspotColors[m])
                    .attr("r", d.r)  // start at the node's radius
                    .style("opacity", 0)
                    .transition().duration(500)
                    .style("opacity", 1)
                    .attr("r", (m, i) => d.r + (i + 1) * 3);
            });
        }

        // Restore function: re-enable all links and update the trade panel checkboxes.
        function restoreLinks() {
            d3.select("#toggleModeButton").attr("disabled", true);
            d3.select("#screenshotButton").attr("disabled", true);

            // Set all links to enabled.
            allLinks.forEach(link => {
                link.disabled = false;
            });

            // Force all trade checkboxes to be checked.
            d3.selectAll('.trade-checkbox').property('checked', true);
            d3.selectAll('.trade-header-checkbox').property('checked', true);

            // Update the network so that all links are shown.
            updateNetwork();
            updateSpectralRadiusDisplay();
            updateDonutCharts();
            updateNetworkStats(allNodes, allLinks);
            hotspots = computeHotSpotMetrics(allNodes, allLinks);
            hotspotsMax = computeHotspotMax(hotspots);
            printHotSpots(hotspots, "topMetrics", 3);
            replotHotspots();
            const newsccs = findSCCs(allNodes, allLinks);
            displaySCCsInCards(newsccs, "sccOutput");

            // If a node is currently selected, update its trade table checkboxes to be checked.
            if (selectedNodeData) {
                updateTradeTable(selectedNodeData);
                replotInOutArbos(selectedNodeData.id);
            }

            // Re-enable the toggle and screenshot buttons after transitions are done.
            d3.timeout(() => {
                d3.select("#toggleModeButton").attr("disabled", null);
                d3.select("#screenshotButton").attr("disabled", null);
            }, 550);
        }

        // ---- Force Simulation Drag Handler ----
        function drag(simulation) {
            function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
            function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
            function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }
            return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
        }

        // ---- Functions to switch between graph and map mode ----
        function switchToMapMode() {
            if (forceSim) forceSim.stop();
            if (!nlMapData) { console.error("NL map data not loaded."); return; }
            const projection = d3.geoIdentity().reflectY(true).fitSize([w, h], nlMapData);
            const path = d3.geoPath().projection(projection);
            const mapLayer = svg.insert("g", ":first-child").attr("class", "map");
            mapLayer.selectAll("path")
                .data(nlMapData.features)
                .enter().append("path")
                .attr("d", path)
                .attr("fill", "none")
                .attr("stroke", "#999");
            if (!svg.select("#mapOverlay").empty()) {
                svg.select("#mapOverlay").remove();
                svg.insert("rect", ":first-child")
                    .attr("id", "mapOverlay")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", w)
                    .attr("height", h)
                    .attr("fill", "black")
                    .attr("opacity", 0.7);
            }
            if (!nlLabelPoints) { console.error("NL label point data not loaded."); }
            else {
                nodeEnter.each(function (d) {
                    const labelFeature = nlLabelPoints.features.find(f => f.properties.statcode === d.id);
                    if (labelFeature) {
                        const coords = projection(labelFeature.geometry.coordinates);
                        d.x = coords[0];
                        d.y = coords[1];
                    }
                });
            }
            updateMapPositionsWithTransition();
        }

        function switchToGraphMode() {
            svg.selectAll(".map").remove();
            nodeEnter.each(function (d) { d.fx = null; d.fy = null; });
            if (forceSim) { forceSim.alpha(1).restart(); }
        }

        // ---- Update Node Positions When Switching to Map Mode ----
        function updateMapPositionsWithTransition() {
            nodeEnter.transition().duration(1000)
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .on("end", function (d) {
                    if (selectedNodeData && selectedNodeData.id === d.id) {
                        updateAnnotationForNode(d, annotationGroup);
                    }
                    if (hoveredNode && hoveredNode.id === d.id) {
                        updateAnnotationForNode(d, annotationGroup);
                    }
                });

            // Record the current node positions for annotation updates.
            allNodes.forEach(node => {
                node.x0 = node.x;
                node.y0 = node.y;
            });

            linkSelection.transition().duration(1000)
                .attr("d", function (d) {
                    const dx = d.target.x - d.source.x,
                        dy = d.target.y - d.source.y,
                        dr = Math.sqrt(dx * dx + dy * dy),
                        adj = getAdjustedTarget(d);
                    return "M" + d.source.x + "," + d.source.y +
                        "A" + dr + "," + dr + " 0 0,1 " + adj.x + "," + adj.y;
                });

            labelSelection.transition().duration(1000)
                .attr("x", d => d.x)
                .attr("y", d => d.y - (d.r + 13));

            //Record the current link positions for annotation updates.
            allLinks.forEach(link => {
                link.x0 = link.source.x;
                link.y0 = link.source.y;
                link.x1 = link.target.x;
                link.y1 = link.target.y;
            });
        }

        // Function to bridge native graph data and JSNetworkX
        // function createJSNetworkxGraph(nodes, links) {
        //     // Create a new directed graph.
        //     const G = new jsnx.DiGraph();

        //     // Add all nodes with their attributes.
        //     nodes.forEach(n => {
        //         G.addNode(n.id, n);
        //     });

        //     // Add only enabled edges.
        //     links.forEach(link => {
        //         if (!link.disabled) {
        //             const source = (typeof link.source === 'object') ? link.source.id : link.source;
        //             const target = (typeof link.target === 'object') ? link.target.id : link.target;
        //             G.addEdge(source, target, { weight: link.weight });
        //         }
        //     });

        //     return G;
        // }

        /**
         * chuLiuEdmonds(nodes, edges, root, direction)
         * 
         * Computes a maximum spanning arborescence using a simplified Chu-Liu/Edmonds approach.
         * 
         * @param {Array} nodes - Array of node objects, each with at least {id: string}.
         * @param {Array} edges - Array of edge objects, each with {source, target, weight}.
         *                        source/target can be either a node object or an ID string.
         * @param {Object} root - The root node object for the arborescence, e.g. {id: "Root"}
         * @param {String} direction - "in" or "out".
         *    - "in":   each node except root has exactly one incoming edge (a standard in-arborescence).
         *    - "out":  each node except root has exactly one outgoing edge (equivalent to reversing edges, 
         *              computing an in-arbo, then reversing them back).
         * @returns {Array} an array of edges ( {source, target, weight} ) forming the maximum arborescence.
         */
        function chuLiuEdmonds(nodes, edges, root, direction) {
            // If OUT-arborescence, reverse edges first.
            let reversed = false;
            let workingEdges = edges;
            if (direction === "out") {
                reversed = true;
                workingEdges = edges.map(e => ({
                    source: e.target,
                    target: e.source,
                    weight: e.weight
                }));
            }

            // ---------------------------
            // Step 1: For each node (except root), pick the single incoming edge of maximum weight
            //         in the (possibly reversed) graph
            // ---------------------------
            let inEdges = {};
            nodes.forEach(node => {
                if (node.id === root.id) return;
                // all edges that lead *into* this node
                const incoming = workingEdges.filter(e => {
                    const t = (typeof e.target === "object") ? e.target.id : e.target;
                    return t === node.id;
                });
                if (incoming.length > 0) {
                    // pick the heaviest edge
                    inEdges[node.id] = incoming.reduce((a, b) => a.weight > b.weight ? a : b);
                }
            });

            // ---------------------------
            // Step 2: Detect a cycle by DFS
            // ---------------------------
            let cycle = null;
            let visited = {};

            // DFS to detect a cycle
            function dfsCycle(nodeId, path) {
                if (visited[nodeId]) {
                    // if visited before in the current path, then there's a cycle
                    const idx = path.indexOf(nodeId);
                    if (idx !== -1) {
                        cycle = path.slice(idx);
                    }
                    return;
                }
                visited[nodeId] = true;
                if (inEdges[nodeId]) {
                    // follow the one incoming edge
                    const src = (typeof inEdges[nodeId].source === "object")
                        ? inEdges[nodeId].source.id
                        : inEdges[nodeId].source;
                    dfsCycle(src, path.concat([nodeId]));
                }
            }

            // run DFS for each node except root
            nodes.forEach(node => {
                if (node.id !== root.id && !visited[node.id]) {
                    dfsCycle(node.id, []);
                }
            });

            // if there's no cycle, there's a valid arborescence
            if (!cycle) {
                // collecting all the inEdges values is enough to define the arborescence
                let result = Object.values(inEdges);

                // if reversed edges for "out", should also reverse the result back
                if (reversed) {
                    result = result.map(e => ({
                        source: e.target,
                        target: e.source,
                        weight: e.weight
                    }));
                }
                return result;
            }

            // ---------------------------
            // Step 3: Contract the cycle
            // ---------------------------
            // create a synthetic node ID for the entire cycle
            let cycleId = cycle.join("_");

            // remove cycle nodes from 'nodes' and add one new "contracted" node
            let contractedNodes = nodes.filter(n => !cycle.includes(n.id));
            contractedNodes.push({ id: cycleId });

            // build new edges with cycle references replaced by 'cycleId'
            let contractedEdges = [];
            for (const e of workingEdges) {
                const s = (typeof e.source === "object") ? e.source.id : e.source;
                const t = (typeof e.target === "object") ? e.target.id : e.target;
                let newS = cycle.includes(s) ? cycleId : s;
                let newT = cycle.includes(t) ? cycleId : t;

                // skip self loops
                if (newS === newT) continue;

                let newWeight = e.weight;
                // if t is in the cycle, but s is not, subtract the weight of that node's chosen edge
                if (cycle.includes(t) && !cycle.includes(s)) {
                    newWeight = e.weight - inEdges[t].weight;
                }

                contractedEdges.push({ source: newS, target: newT, weight: newWeight });
            }

            // recursively compute arbo on contracted graph
            const contractedRoot = (root.id === cycleId) ? { id: cycleId } : root;
            let T = chuLiuEdmonds(contractedNodes, contractedEdges, contractedRoot, "in");
            // ^ pass direction = "in" here

            // ---------------------------
            // Step 4: Expand the cycle
            // ---------------------------
            // find the edge pointing to the cycleId in T
            let cycleEdge = T.find(e => {
                const tid = (typeof e.target === "object") ? e.target.id : e.target;
                return tid === cycleId;
            });

            // remove that edge from T
            T = T.filter(e => {
                const tid = (typeof e.target === "object") ? e.target.id : e.target;
                return tid !== cycleId;
            });

            // restore the cycle's chosen edges
            cycle.forEach(id => {
                T.push(inEdges[id]);
            });

            // if reversed edges for "out", should also reverse the final result back
            if (reversed) {
                T = T.map(e => ({
                    source: e.target,
                    target: e.source,
                    weight: e.weight
                }));
            }

            return T;
        }

        /**
         * visualizeArborescence(treeEdges, containerSelector, rootId)
         *
         * Displays a directed arborescence in a top-down tree layout using d3.tree().
         * If 'treeEdges' is empty, shows "No arborescence found."
         *
         * @param {Array} treeEdges - Arborescence edges: {source, target, weight}
         * @param {String} containerSelector - e.g. "#inArboSVG"
         * @param {String} rootId - ID of the root node
         */
        function visualizeArborescence(treeEdges, containerSelector, rootId) {
            // 1) Clear the container
            const container = d3.select(containerSelector);
            container.selectAll("*").remove();

            // If no edges, display message
            if (!treeEdges || treeEdges.length === 0) {
                container.append("text")
                    .attr("x", 10)
                    .attr("y", 20)
                    .text("No major routes found.");
                return;
            }

            // 2) Collect node IDs from edges
            let nodeIds = new Set();
            treeEdges.forEach(e => {
                let s = (typeof e.source === "object") ? e.source.id : e.source;
                let t = (typeof e.target === "object") ? e.target.id : e.target;
                nodeIds.add(s);
                nodeIds.add(t);
            });

            // 3) Filter allNodes to only those in arbo
            let treeNodes = allNodes.filter(n => nodeIds.has(n.id));

            // 4) Build adjacency: childrenMap[parentId] = [childId1, childId2, ...]
            let childrenMap = {};
            treeNodes.forEach(n => {
                childrenMap[n.id] = [];
            });
            // Each edge is parent -> child
            treeEdges.forEach(e => {
                let s = (typeof e.source === "object") ? e.source.id : e.source;
                let t = (typeof e.target === "object") ? e.target.id : e.target;
                if (childrenMap[s]) {
                    childrenMap[s].push(t);
                }
            });

            // 5) Build a nested structure for d3.tree with 'rootId' as the root
            function buildHierarchy(nodeId) {
                return {
                    name: nodeId,
                    children: (childrenMap[nodeId] || []).map(childId => buildHierarchy(childId))
                };
            }

            // If rootId not in treeNodes, show error
            let rootNode = treeNodes.find(n => n.id === rootId);
            if (!rootNode) {
                container.append("text")
                    .attr("x", 10)
                    .attr("y", 20)
                    .text(`Root ${rootId} not found in arborescence.`);
                return;
            }

            let rootData = buildHierarchy(rootId);

            // 6) Create an <svg> inside the container
            let width = parseInt(container.style("width"), 10);
            let height = parseInt(container.style("height"), 10);

            let svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);

            // 7) Use d3.tree() for a top-down layout
            let layout = d3.tree().size([width - 40, height - 40]);

            // 8) Convert to a d3.hierarchy
            let root = d3.hierarchy(rootData, d => d.children);

            // 9) Compute node/link positions
            layout(root);
            // After layout, each node has: d.x => horizontal, d.y => vertical

            // 10) Draw edges (links)
            svg.selectAll(".link")
                .data(root.links())
                .enter()
                .append("path")
                .attr("class", "link")
                .attr("fill", "none")
                .attr("stroke", "#555")
                .attr("stroke-width", 2)
                .attr("d", d3.linkVertical()
                    .x(d => d.x + 20) // shift horizontally by 20
                    .y(d => d.y + 30) // shift vertically by 20
                );

            // 11) Draw nodes
            let nodeGroup = svg.selectAll(".node")
                .data(root.descendants())
                .enter()
                .append("g")
                .attr("class", "node")
                // place each node at (d.x, d.y), plus some offset
                .attr("transform", d => `translate(${d.x + 20},${d.y + 30})`);

            // 12) Circles for each node
            nodeGroup.append("circle")
                .attr("r", 5)
                .attr("fill", d => (d.data.name === rootId) ? "orange" : "#69b3a2");

            // 13) Labels
            nodeGroup.append("text")
                .attr("dy", -2)
                .attr("dx", 14)
                .attr("font-size", "8px")
                .attr("text-anchor", "middle")
                .attr("transform", (d) => `rotate(-45)`)
                .text(d => d.data.name);
        }


        // ---- Maximum Clique Computation with Reciprocal Edges ----
        // Only consider an undirected edge between two nodes if both A->B and B->A exist.
        function computeMaximumClique() {
            let directedEdges = new Set();
            // Record all directed edges.
            allLinks.forEach(link => {
                const s = (typeof link.source === "object") ? link.source.id : link.source;
                const t = (typeof link.target === "object") ? link.target.id : link.target;
                directedEdges.add(s + "->" + t);
            });
            // Build the undirected graph using only reciprocal edges.
            let adjList = {};
            allNodes.forEach(n => { adjList[n.id] = new Set(); });
            allLinks.forEach(link => {
                const s = (typeof link.source === "object") ? link.source.id : link.source;
                const t = (typeof link.target === "object") ? link.target.id : link.target;
                // Only add the edge if both directions exist.
                if (directedEdges.has(s + "->" + t) && directedEdges.has(t + "->" + s)) {
                    adjList[s].add(t);
                    adjList[t].add(s);
                }
            });

            let maxClique = [];

            function bronKerboschPivot(R, P, X) {
                if (P.length === 0 && X.length === 0) {
                    if (R.length > maxClique.length) {
                        maxClique = R;
                    }
                    return;
                }
                // Choose a pivot from P ∪ X.
                let pivotCandidates = P.concat(X);
                let pivot = pivotCandidates[0];
                let pivotNeighbors = adjList[pivot.id];
                // Only consider vertices in P that are not neighbors of the pivot.
                let PwithoutNeighbors = P.filter(v => !pivotNeighbors.has(v.id));
                for (let v of PwithoutNeighbors) {
                    let newR = R.concat([v]);
                    let newP = P.filter(u => adjList[v.id].has(u.id));
                    let newX = X.filter(u => adjList[v.id].has(u.id));
                    bronKerboschPivot(newR, newP, newX);
                    P = P.filter(u => u.id !== v.id);
                    X.push(v);
                }
            }

            bronKerboschPivot([], allNodes.slice(), []);
            return maxClique;
        }

        /**
         * computeMaxCliqueReciprocal()
         * 
         * Finds the maximum cardinality clique in the “undirected” subgraph formed by
         * reciprocal edges
         *
         * Returns an array of node objects forming the largest clique.
         */
        function computeMaxCliqueReciprocal() {
            // 1) Gather all directed edges into a set like "A->B"
            let directedEdges = new Set();
            allLinks.forEach(link => {
                const s = (typeof link.source === "object") ? link.source.id : link.source;
                const t = (typeof link.target === "object") ? link.target.id : link.target;
                directedEdges.add(s + "->" + t);
            });

            // 2) Build adjacency for the "undirected" subgraph (reciprocal edges only)
            let adjList = {};
            allNodes.forEach(n => {
                adjList[n.id] = new Set();
            });

            allLinks.forEach(link => {
                const s = (typeof link.source === "object") ? link.source.id : link.source;
                const t = (typeof link.target === "object") ? link.target.id : link.target;
                // Only add s<->t if s->t and t->s are both present
                if (directedEdges.has(s + "->" + t) && directedEdges.has(t + "->" + s)) {
                    adjList[s].add(t);
                    adjList[t].add(s);
                }
            });

            // 3) The Bron–Kerbosch recursive approach
            let maxClique = [];

            /**
             * bronKerboschPivot(R, P, X)
             * @param {Array} R - array of node objects currently in the clique
             * @param {Array} P - array of node objects that can still join the clique
             * @param {Array} X - array of node objects that must be excluded
             */
            function bronKerboschPivot(R, P, X) {
                // If neither P nor X has possible candidates, R is a maximal clique
                if (P.length === 0 && X.length === 0) {
                    // Update maxClique if this clique is larger
                    if (R.length > maxClique.length) {
                        // Store a copy, not a reference
                        maxClique = R.slice();
                    }
                    return;
                }

                if (P.length === 0 && X.length > 0) {
                    // There's no candidate to expand with, so it's done
                    if (R.length > maxClique.length) {
                        maxClique = R.slice();
                    }
                    return;
                }
                if (P.length + R.length <= maxClique.length) {
                    // Pruning: no chance to exceed current maximum
                    return;
                }

                // Combine P ∪ X to choose a pivot
                let pivotCandidates = P.concat(X);
                if (pivotCandidates.length === 0) {
                    // If there's no pivot, just stop
                    if (R.length > maxClique.length) {
                        maxClique = R.slice();
                    }
                    return;
                }

                // Choose a pivot arbitrarily
                let pivot = pivotCandidates[0];
                // pivotNeighbors is the set of string IDs adjacent to pivot.id
                let pivotNeighbors = adjList[pivot.id] || new Set();

                // P \ pivotNeighbors
                let PwithoutNeighbors = P.filter(v => !pivotNeighbors.has(v.id));

                for (let v of PwithoutNeighbors) {
                    // vNeighbors is the set of neighbors for node v
                    let vNeighbors = adjList[v.id] || new Set();

                    // newR = R ∪ {v}
                    let newR = R.concat([v]);

                    // newP = P ∩ N(v)
                    let newP = P.filter(u => vNeighbors.has(u.id));

                    // newX = X ∩ N(v)
                    let newX = X.filter(u => vNeighbors.has(u.id));

                    bronKerboschPivot(newR, newP, newX);

                    // Remove v from P, add to X
                    P = P.filter(u => u.id !== v.id);
                    X.push(v);
                }
            }

            // 4) Initially, R = empty, P = allNodes, X = empty
            let R = [];
            let P = allNodes.slice(); // copy all node objects
            let X = [];

            bronKerboschPivot(R, P, X);

            return maxClique;
        }

        /**
         * findSCCs(nodes, edges)
         *
         * Uses Tarjan’s Algorithm to find strongly connected components (SCCs)
         * in a directed graph.
         *
         * @param {Array} nodes - Array of node objects, each with at least {id: string}.
         * @param {Array} edges - Array of directed edges: {source, target}.
         *                        source/target may be node objects or strings.
         * @returns {Array} array of SCCs, where each SCC is array of node IDs
         *
         * Complexity: O(V + E)
         */
        function findSCCs(nodes, edges) {
            // Filter out disabled links.
            const enabledEdges = edges.filter(e => !e.disabled);

            // 1) Build adjacency list from enabled edges
            const adj = buildAdjList(nodes, enabledEdges);

            // 2) Tarjan’s data structures
            let indexCounter = 0;
            const stack = [];
            const onStack = {};
            const index = {};     // index[nodeId]
            const lowLink = {};   // lowLink[nodeId]
            const sccList = [];   // final array of SCCs

            nodes.forEach(n => {
                index[n.id] = -1;     // uninitialized
                lowLink[n.id] = -1;
                onStack[n.id] = false;
            });

            // Tarjan’s stronglyConnected procedure
            function strongConnect(v) {
                // Set the depth index for v.
                index[v] = indexCounter;
                lowLink[v] = indexCounter;
                indexCounter++;
                stack.push(v);
                onStack[v] = true;

                // Consider successors of v.
                for (let w of adj[v]) {
                    if (index[w] === -1) {
                        // Successor w has not yet been visited; recurse on it.
                        strongConnect(w);
                        lowLink[v] = Math.min(lowLink[v], lowLink[w]);
                    } else if (onStack[w]) {
                        // Successor w is in the stack, meaning v is part of a cycle.
                        lowLink[v] = Math.min(lowLink[v], index[w]);
                    }
                }

                // If v is a root node, pop the stack and generate an SCC.
                if (lowLink[v] === index[v]) {
                    const scc = [];
                    let w = null;
                    do {
                        w = stack.pop();
                        onStack[w] = false;
                        scc.push(w);
                    } while (w !== v);
                    sccList.push(scc);
                }
            }

            // 3) Run Tarjan’s procedure for each unvisited node.
            nodes.forEach(n => {
                if (index[n.id] === -1) {
                    strongConnect(n.id);
                }
            });

            return sccList;
        }

        function computeSpectralRadius(allNodes, allLinks, maxIter = 100, tol = 1e-6) {
            // 1. Filter out disabled links.
            const enabledLinks = allLinks.filter(link => !link.disabled);

            // 2. Create a mapping from node id to index.
            const n = allNodes.length;
            const idToIndex = {};
            allNodes.forEach((node, i) => {
                idToIndex[node.id] = i;
            });

            // 3. Build the adjacency matrix.
            // Here use a 2D array with dimensions n x n, initialized to 0.
            const A = Array.from({ length: n }, () => Array(n).fill(0));
            enabledLinks.forEach(link => {
                const source = (typeof link.source === "object") ? link.source.id : link.source;
                const target = (typeof link.target === "object") ? link.target.id : link.target;
                const i = idToIndex[source];
                const j = idToIndex[target];
                if (i !== undefined && j !== undefined) {
                    A[i][j] += link.weight || 1;
                }
            });

            // 4. Use power iteration to estimate the spectral radius.
            // Start with a random vector (or a vector of ones).
            let v = Array(n).fill(1);

            // Function to compute matrix-vector multiplication.
            function matVecMult(matrix, vec) {
                const result = Array(vec.length).fill(0);
                for (let i = 0; i < matrix.length; i++) {
                    for (let j = 0; j < matrix[i].length; j++) {
                        result[i] += matrix[i][j] * vec[j];
                    }
                }
                return result;
            }

            // Function to compute the Euclidean norm of a vector.
            function norm(vec) {
                return Math.sqrt(vec.reduce((sum, x) => sum + x * x, 0));
            }

            let eigenvalue = 0;
            for (let iter = 0; iter < maxIter; iter++) {
                // Multiply matrix by vector.
                let newV = matVecMult(A, v);
                const newNorm = norm(newV);
                // Normalize the new vector.
                newV = newV.map(x => x / newNorm);

                // Estimate eigenvalue using Rayleigh quotient.
                const Av = matVecMult(A, newV);
                const rayleigh = newV.reduce((sum, x, i) => sum + x * Av[i], 0);

                // Check for convergence.
                if (Math.abs(rayleigh - eigenvalue) < tol) {
                    eigenvalue = rayleigh;
                    break;
                }
                eigenvalue = rayleigh;
                v = newV;
            }

            return eigenvalue;
        }

        // Helper: build adjacency list for a directed graph
        function buildAdjList(nodes, edges) {
            const adj = {};
            nodes.forEach(n => { adj[n.id] = []; });
            edges.forEach(e => {
                const s = (typeof e.source === "object") ? e.source.id : e.source;
                const t = (typeof e.target === "object") ? e.target.id : e.target;
                if (!adj[s]) {
                    adj[s] = [];
                }
                adj[s].push(t);
            });
            return adj;
        }

        /**
         * displaySCCsInCards(sccs, containerId)
         *
         * Renders the array of strongly connected components (SCCs) as cards with a collapsible details section.
         *
         * @param {Array} sccs - Array of SCCs, where each SCC is an array of node IDs
         * @param {String} containerId - The DOM element ID where the cards will be placed
         */
        function displaySCCsInCards(sccs, containerId) {
            const container = document.getElementById(containerId);
            if (!container) {
                console.warn("Container with ID", containerId, "not found.");
                return;
            }

            // If no SCCs, display a simple message
            if (!sccs || sccs.length === 0) {
                container.innerHTML = "<p>No strongly connected components found.</p>";
                return;
            }

            // Start building the HTML
            let html = ``;

            sccs.forEach((component, index) => {
                // For brevity, show first three nodes as a summary.
                const summaryCount = 3;
                const summaryNodes = component.slice(0, summaryCount).join(", ");
                const remainingCount = component.length - summaryCount;
                const fullList = component.join(", ");

                html += `<div class="scc-card">
                <div class="scc-header">
                    <span class="scc-index">Cluster ${index + 1}</span>
                    <span class="scc-summary">
                    ${summaryNodes}${remainingCount > 0 ? " ..." : ""}
                    </span>
                </div>`;

                if (remainingCount > 0) {
                    html += `<details class="scc-details">
                    <summary>Show full list</summary>
                    <p>${fullList}</p>
                </details>`;
                }

                html += `</div>`;
            });

            container.innerHTML = html;
        }


        // Visualize the maximum clique using a circular layout.
        function visualizeClique(cliqueNodes) {
            let cliqueSVG = d3.select("#cliqueSVG");
            cliqueSVG.selectAll("*").remove();
            if (cliqueNodes.length === 0) {
                cliqueSVG.append("text")
                    .attr("x", 10)
                    .attr("y", 20)
                    .text("No reciprocal clique found.");
                return;
            }
            // Create edges for every pair of nodes in the clique.
            let edges = [];
            for (let i = 0; i < cliqueNodes.length; i++) {
                for (let j = i + 1; j < cliqueNodes.length; j++) {
                    edges.push({ source: cliqueNodes[i], target: cliqueNodes[j] });
                }
            }
            // Arrange nodes in a circle.
            let width = parseInt(cliqueSVG.style("width"));
            let height = parseInt(cliqueSVG.style("height"));
            let cx = width / 2, cy = height / 2;
            let radius = Math.min(width, height) / 2 - 40;
            let n = cliqueNodes.length;
            cliqueNodes.forEach((node, i) => {
                let angle = 2 * Math.PI * i / n;
                node.cx = cx + radius * Math.cos(angle);
                node.cy = cy + radius * Math.sin(angle);
            });
            // Draw edges.
            cliqueSVG.selectAll("line")
                .data(edges)
                .enter()
                .append("line")
                .attr("x1", d => d.source.cx)
                .attr("y1", d => d.source.cy)
                .attr("x2", d => d.target.cx)
                .attr("y2", d => d.target.cy)
                .attr("stroke", "#999")
                .attr("stroke-width", 1);
            // Draw nodes.
            cliqueSVG.selectAll("circle")
                .data(cliqueNodes)
                .enter()
                .append("circle")
                .attr("cx", d => d.cx)
                .attr("cy", d => d.cy)
                .attr("r", 10)
                .attr("fill", "#69b3a2")
                .attr("stroke", "red")
                .attr("stroke-width", 2);
            // Add labels.
            cliqueSVG.selectAll("text")
                .data(cliqueNodes)
                .enter()
                .append("text")
                .attr("x", d => d.cx)
                .attr("y", d => d.cy)
                .attr("dy", ".35em")
                .attr("text-anchor", "middle")
                .text(d => d.id);
        }

        /**
         * visualizeCliqueAsForce(cliqueNodes)
         *
         * Uses a d3 force layout to display the maximum clique as a standard graph (with edges and node labels).
         *
         * @param {Array} cliqueNodes - Each element is an object representing a node, e.g. { id, statnaam }.
         */
        function visualizeCliqueAsForce(cliqueNodes) {
            const svg = d3.select("#cliqueSVG");
            svg.selectAll("*").remove();

            // If no clique nodes, show text
            if (!cliqueNodes || cliqueNodes.length === 0) {
                svg.append("text")
                    .attr("x", 10)
                    .attr("y", 20)
                    .text("No reciprocal clique found.");
                return;
            }

            // Build pairwise edges for the clique
            const edges = [];
            for (let i = 0; i < cliqueNodes.length; i++) {
                for (let j = i + 1; j < cliqueNodes.length; j++) {
                    edges.push({ source: cliqueNodes[i], target: cliqueNodes[j] });
                }
            }

            // Convert style to numeric
            const width = parseInt(svg.style("width"), 10);
            const height = parseInt(svg.style("height"), 10);

            // D3 force simulation
            const simulation = d3.forceSimulation(cliqueNodes)
                .force("charge", d3.forceManyBody().strength(-80))  // repel
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collide", d3.forceCollide(40))              // spacing
                .force("link", d3.forceLink(edges).distance(80).strength(1));

            // Draw edges
            const link = svg.selectAll("line")
                .data(edges)
                .enter()
                .append("line")
                .attr("stroke", "#999")
                .attr("stroke-width", 1);

            // Draw node "boxes" or "labels"
            const node = svg.selectAll(".cliqueNode")
                .data(cliqueNodes, d => d.id)
                .enter()
                .append("g")
                .attr("class", "cliqueNode");

            // Draw a rect
            node.append("rect")
                .attr("width", 60)
                .attr("height", 30)
                .attr("fill", "#69b3a2")
                .attr("rx", 5)
                .attr("ry", 5)
                .attr("stroke", "red")
                .attr("stroke-width", 2)
                .attr("x", -30)   // center rect around the node’s x,y
                .attr("y", -15);

            // Add text label inside the rect
            node.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", "0.35em")
                .text(d => d.id);

            // On each tick, update positions
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("transform", d => `translate(${d.x},${d.y})`);
            });
        }

        function replotInOutArbos(newRootId) {
            // 0) Clear the existing SVGs if newRootId is null
            if (!newRootId) {
                d3.select("#inArboSVG").selectAll("*").remove();
                d3.select("#outArboSVG").selectAll("*").remove();
                return;
            }

            // 1) Find the new root node object
            let newRoot = allNodes.find(n => n.id === newRootId);
            if (!newRoot) {
                console.warn("No root found for ID:", newRootId);
                return;
            }

            // 2) Filter out disabled links from allLinks.
            const enabledLinks = allLinks.filter(link => !link.disabled);

            // 3) Compute in-arbo and out-arbo using only enabled links.
            let inArbo = chuLiuEdmonds(allNodes, enabledLinks, newRoot, "in");
            let outArbo = chuLiuEdmonds(allNodes, enabledLinks, newRoot, "out");

            // 4) Visualize the computed arbos.
            visualizeArborescence(inArbo, "#inArboSVG", newRootId);
            // visualizeArborescence(outArbo, "#outArboSVG", newRootId);
        }


        function attachInfoBoxListeners() {
            document.querySelectorAll('.info-container').forEach(container => {
                const infoBox = container.querySelector('.info-box');

                container.addEventListener('mouseenter', () => {
                    // Get the container's position relative to the viewport
                    const rect = container.getBoundingClientRect();

                    // Detach the tooltip from its current parent and append it to the body
                    document.body.appendChild(infoBox);

                    // Set the tooltip's style to fixed positioning so it's not cropped
                    infoBox.style.position = 'fixed';
                    // Position it above the container (adjust offsets as needed)
                    infoBox.style.top = (rect.top - infoBox.offsetHeight - 5) + 'px';
                    infoBox.style.left = (rect.left + rect.width / 2 - infoBox.offsetWidth / 2) + 'px';

                    // Show the tooltip
                    infoBox.style.visibility = 'visible';
                    infoBox.style.opacity = '0.85';
                });

                container.addEventListener('mouseleave', () => {
                    // Hide the tooltip
                    infoBox.style.visibility = 'hidden';
                    infoBox.style.opacity = '0';

                    // Reattach the tooltip to the original container
                    container.appendChild(infoBox);
                    // Reset the tooltip's position so it can be absolutely positioned within the container again
                    infoBox.style.position = 'absolute';
                });
            });
        }

        // ---- CSV File Upload ----
        document.getElementById('csvFileInput').addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            // When the file is loaded, parse it as CSV
            reader.onload = function (e) {
                // Initialize data structures
                const text = e.target.result;
                const data = d3.csvParse(text);
                const nodesMap = {}, links = [];

                // Iterate over each row in the CSV
                data.forEach(d => {
                    const source = d.COROP_LEV, target = d.COROP_AFN, weight = +d.AANTAL, disabled = 0;
                    // Skip rows if the source or target is missing/NA.
                    if (!source || !target || source.toUpperCase() === "NA" || target.toUpperCase() === "NA") {
                        return; // Just skip this row.
                    }
                    if (!nodesMap[source]) {
                        nodesMap[source] = { id: source, tradeTotal: 0 };
                    }
                    if (!nodesMap[target]) {
                        nodesMap[target] = { id: target, tradeTotal: 0 };
                    }
                    nodesMap[source].tradeTotal += weight;
                    nodesMap[target].tradeTotal += weight;
                    links.push({ source, target, weight, disabled });
                });

                // Convert nodesMap to an array of nodes
                const nodes = Object.values(nodesMap);
                allNodes = nodes;
                nodes.forEach(d => {
                    d.statnaam = (nlLabelPoints && nlLabelPoints.features) ?
                        (nlLabelPoints.features.find(f => f.properties.statcode === d.id)?.properties.statnaam || d.id)
                        : d.id;
                });
                allLinks = links;

                // Update network stats
                updateNetworkStats(allNodes, allLinks);

                // Compute and print 3 hotpots per metric
                hotspots = computeHotSpotMetrics(allNodes, allLinks);
                hotspotsMax = computeHotspotMax(hotspots);
                printHotSpots(hotspots, "topMetrics", 3);

                // Create the network visualization
                createNetwork(allNodes, allLinks);

                // Find strongly connected components (SCCs) and display them in a table
                const sccs = findSCCs(allNodes, allLinks);
                displaySCCsInCards(sccs, "sccOutput");

                // Initialize spectral radius display
                initSpectralRadiusDisplay();

                // Compute and visualize the maximum clique (using reciprocal edges only)
                // let maxClique = computeMaxCliqueReciprocal();
                // visualizeCliqueAsForce(maxClique);

                // Enable toggle button after CSV is loaded.
                document.getElementById("toggleModeButton").disabled = null;

                // Enable screenshot button after CSV is loaded.
                document.getElementById("screenshotButton").disabled = null;

                // Enable restore button after CSV is loaded.
                document.getElementById("restoreButton").disabled = null;
            };

            // Read the file as text
            reader.readAsText(file);
        });

        function initSpectralRadiusDisplay() {
            // Compute the initial spectral radius using all nodes/links (only enabled links if applicable).
            initialSpectralRadius = computeSpectralRadius(allNodes, allLinks);

            const displayElement = document.getElementById("spectralRadiusDisplay");
            displayElement.innerHTML = `
                <i class="fa-solid fa-virus"></i> Risk Score: <span class="current-sr">1.000</span> <span class="initial-sr">(1.000)</span>
            `;

            displayElement.querySelector(".initial-sr").style.color = "salmon";
            displayElement.querySelector(".current-sr").style.color = "salmon";
        }

        document.addEventListener('DOMContentLoaded', function () {
            const introOverlay = document.getElementById('introOverlay');
            const okButton = document.getElementById('introOkButton');
            const dontShowAgain = document.getElementById('dontShowAgain');

            // If the user already opted to hide the intro, skip showing it entirely
            if (localStorage.getItem('hideIntro') === 'true') {
                // Immediately hide (no animation)
                introOverlay.style.display = 'none';
            }

            // Otherwise, the overlay is visible by default and can fade in
            okButton.addEventListener('click', function () {
                // If the user checked "Do not show again", store that choice.
                if (dontShowAgain.checked) {
                    localStorage.setItem('hideIntro', 'true');
                }

                // Trigger the fade-out animation by adding a 'hide' class
                introOverlay.classList.add('hide');
            });

            // Once the fade-out completes, fully remove overlay from view
            introOverlay.addEventListener('animationend', function (e) {
                // Only hide if the 'hide' animation has been triggered
                if (introOverlay.classList.contains('hide')) {
                    introOverlay.style.display = 'none';
                }
            });
        });

        // Initialize Vivus on the SVG inside the card header
        var drawDuration = 24;
        var myAnim = new Vivus('mySVG', {
            duration: drawDuration,
            start: 'autostart',
            type: 'scenario-sync'
        });

        var animator = function () {
            myAnim.play();
        };

        function fadeInNodes(step, maxStep) {
            setTimeout(() => {
                // Select all nodes for the current step
                const nodes = document.querySelectorAll('.circle.step' + step);
                nodes.forEach(node => {
                    node.classList.add('blue-bg');
                });
                if (step < maxStep) {
                    fadeInNodes(++step, maxStep);
                }
            }, 1000);
        }

        window.addEventListener('load', function () {
            setTimeout(() => {
                fadeInNodes(1, 5);
            }, 1000);
        });

        // Event listener for the file upload widget
        document.getElementById("csvFileInput").addEventListener("change", function (event) {
            const fileNameDisplay = document.getElementById("fileName");
            fileNameDisplay.textContent = event.target.files.length > 0 ? event.target.files[0].name : "No file selected";
        });

        function downloadSvg() {
            // Generate filename based on current timestamp and a random suffix
            const timestamp = new Date().toISOString().replace(/[-:]/g, "").replace("T", "_").split(".")[0];
            const filename = `network_${timestamp}_${Math.random().toString(36).substring(7)}.png`;

            // Download the SVG as PNG
            saveSvgAsPng(document.getElementById("mainFigureSVG"), filename);
        }

        // Event listener for the screenshot button to trigger the download
        document.getElementById("screenshotButton").addEventListener("click", downloadSvg);

        // Attach an event listener to the restore button.
        document.getElementById("restoreButton").addEventListener("click", restoreLinks);

        // Define Keyboard Shortcuts for the functionalities
        // Shortcut for opening a csv file: Press 'o'
        document.addEventListener("DOMContentLoaded", function () {
            document.addEventListener("keydown", function (event) {
                if (event.key === "o") {  // Press 'o' to open a CSV file
                    document.getElementById("csvFileInput").click();
                }
            });
        });

        // Shortcut for taking a screenshot: Press 'r'
        document.addEventListener("DOMContentLoaded", function () {
            const screenshotButton = document.getElementById("screenshotButton");

            // Enable keyboard shortcut when the screenshot button is enabled
            document.addEventListener("keydown", function (event) {
                if (event.key === "r") {  // Press 'r' to take a screenshot
                    if (!screenshotButton.disabled) {
                        event.preventDefault(); // Prevent browser save shortcut
                        screenshotButton.click(); // Trigger button click
                    }
                }
            });
        });
        // Shortcut for toggling the network mode: Press 'm'
        document.addEventListener("DOMContentLoaded", function () {
            const toggleModeButton = document.getElementById("toggleModeButton");

            // Enable keyboard shortcut when the toggle button is enabled
            document.addEventListener("keydown", function (event) {
                if (event.key === "m") {  // Press 'm' to toggle network mode
                    if (!toggleModeButton.disabled) {
                        event.preventDefault(); // Prevent browser save shortcut
                        toggleModeButton.click(); // Trigger button click
                    }
                }
            });
        });

        // Shortcut for quitting the focus mode: Press 'q'
        // Calls clearSelection(false) to remove the focus from the selected node
        document.addEventListener("DOMContentLoaded", function () {
            document.addEventListener("keydown", function (event) {
                if (event.key === "q") {  // Press 'q' to quit focus mode
                    clearSelection(false);
                }
            });
        });

        // Shortcut to simulate click on Statistics header: Press 's'
        document.addEventListener("DOMContentLoaded", function () {
            document.addEventListener("keydown", function (event) {
                if (event.key === "s") {  // Press 's' to simulate click on Statistics header
                    document.getElementById("statsHeader").click();
                }
            });
        });

        // Shortcut to simulate click on Hotspots header: Press 'h'
        document.addEventListener("DOMContentLoaded", function () {
            document.addEventListener("keydown", function (event) {
                if (event.key === "h") {  // Press 'h' to simulate click on Hotspots header
                    document.getElementById("hotspotsHeader").click();
                }
            });
        });

        // Shortcut to simulate click on SCCs (Trade Clusters) header: Press 'c'
        document.addEventListener("DOMContentLoaded", function () {
            document.addEventListener("keydown", function (event) {
                if (event.key === "c") {  // Press 'c' to simulate click on SCCs header
                    document.getElementById("sccHeader").click();
                }
            });
        });

        // Shortcut to switch between focal nodes: Press 'up' or 'down' arrow keys
        document.addEventListener("keydown", function (e) {
            if (e.key === "ArrowDown" || e.key === "ArrowUp") {
                e.preventDefault();

                // Get all node elements. They should have been attached to .nodeGroup.
                const nodesArray = d3.selectAll(".nodeGroup").nodes();
                if (!nodesArray.length) return;

                // Determine the current index based on selectedNodeData (if any)
                let currentIndex = -1;
                if (selectedNodeData) {
                    currentIndex = nodesArray.findIndex(el => el.__data__.id === selectedNodeData.id);
                }
                // If no node is selected or not found, default to the first node.
                if (currentIndex === -1) {
                    currentIndex = 0;
                } else {
                    // Update index: ArrowDown goes to the next node; ArrowUp to the previous.
                    if (e.key === "ArrowDown") {
                        currentIndex = (currentIndex + 1) % nodesArray.length;
                    } else if (e.key === "ArrowUp") {
                        currentIndex = (currentIndex - 1 + nodesArray.length) % nodesArray.length;
                    }
                }

                // Dispatch a synthetic click event on the selected node element.
                nodesArray[currentIndex].dispatchEvent(new MouseEvent("click", {
                    bubbles: true,
                    cancelable: true
                }));
            }
        });

        // Match the widths of the screenshot and restore buttons
        function matchButtonWidths() {
            const screenshotButton = document.getElementById("screenshotButton");
            const restoreButton = document.getElementById("restoreButton");

            if (screenshotButton && restoreButton) {
                const width = screenshotButton.offsetWidth; // Get the screenshot button's width
                restoreButton.style.width = width + "px"; // Apply the same width to restore button
            }
        }

        // Run the function after page load
        window.onload = matchButtonWidths;

        // Reapply on window resize to ensure consistency
        window.addEventListener("resize", matchButtonWidths);

    </script>
</body>

</html>