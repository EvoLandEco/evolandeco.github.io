<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>HerdLink - NL Livestock Trade Network Analyser</title>
    <!-- Load Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Load Local CSS -->
    <link rel="stylesheet" type="text/css" href="assets/css/herdlink.css">
    <!-- Load D3.js -->
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- Load jLouvain -->
    <script type="text/javascript" src="assets/js/jLouvain.js"></script>
    <!-- Load fontawesome -->
    <script src="https://kit.fontawesome.com/a14764fea8.js" crossorigin="anonymous"></script>
    <!-- Load Vivus -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vivus/0.3.1/vivus.min.js"></script>
</head>

<body>
    <!-- Introductory overlay -->
    <div id="introOverlay" class="intro-overlay">
        <div class="intro-content">
            <h2>About HerdLink</h2>
            <p>
                HerdLink handles network data locally. Here’s a quick guide on how to use it:
            <ul>
                <li>Choose your CSV file using the file input on the left.</li>
                <li>Switch between graph and map views using the button.</li>
                <li>Click on a node to enter focus mode.</li>
                <li>Explore detailed stats and information in the right panel.</li>
                <li>Click on the focal node again to quit focus mode.</li>
            </ul>
            </p>
            <label>
                <input type="checkbox" id="dontShowAgain"> Do not show again
            </label>
            <br>
            <button id="introOkButton">OK</button>
        </div>
    </div>

    <!-- Hover tooltip for nodes and edges -->
    <div id="tooltip" class="tooltip"></div>

    <!-- Main container: three columns -->
    <div id="mainContainer">
        <!-- Left Column: Controls and Network Stats -->
        <div id="col1">
            <div class="card">
                <!-- TOP SECTION: Fixed header & controls -->
                <div class="col1-top">
                    <div class="card-header">
                        <!-- Row 1: Logo/Banner -->
                        <div class="header-row header-row-1">
                            <div class="logo-container">
                                <h4>HerdLink</h4>
                            </div>
                            <div class="svg-container">
                                <svg id="mySVG" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 300">
                                    <circle class="circle blue-bg" cx="58.14" cy="114.94" r="10.72" />
                                    <circle class="line" cx="58.25" cy="115" r="15.33" />
                                    <!-- Step 1 -->
                                    <!-- Connectors -->
                                    <path data-async class="line" d="M58.25 99.67V70" />
                                    <path data-async class="line" d="M70.06 105.22l32.11-26.66" />
                                    <path data-async class="line" d="M70.54 124.17l23.61 19.3" />
                                    <path data-async class="line" d="M55.75 130.13L40.25 211" />
                                    <path class="line" d="M45.96 124.17l-31.81 19.72" />
                                    <!-- Node Outlines -->
                                    <circle data-async class="line" cx="58.25" cy="66" r="4.25" />
                                    <circle data-async class="line" cx="105.25" cy="76" r="4.25" />
                                    <circle data-async class="line" cx="97.25" cy="146" r="4.25" />
                                    <circle data-async class="line" cx="40.25" cy="215" r="4.25" />
                                    <circle class="line" cx="10.75" cy="146" r="4.25" />
                                    <!-- Node Fills -->
                                    <circle data-async class="circle step1" cx="58.25" cy="66" r="4" />
                                    <circle data-async class="circle step1" cx="105.25" cy="76" r="4" />
                                    <circle data-async class="circle step1" cx="97.25" cy="146" r="4" />
                                    <circle data-async class="circle step1" cx="40.25" cy="215" r="4" />
                                    <circle class="circle step1" cx="10.75" cy="146" r="4" />
                                    <!-- Step 2 -->
                                    <!-- Connectors -->
                                    <path data-async class="line" d="M61.42 63.56l46.62-34.68" />
                                    <path data-async class="line" d="M109.25 76l42-.01" />
                                    <path data-async class="line" d="M99.8 142.92l52.9-63.84" />
                                    <path data-async class="line" d="M94.7 149.08l-52 62.76" />
                                    <path class="line" d="M38.55 211.38l-26.23-61.7" />
                                    <!-- Node Outlines -->
                                    <circle data-async class="line" cx="111.25" cy="26.5" r="4.25" />
                                    <circle class="line" cx="155.25" cy="75.99" r="4.25" />
                                    <!-- Node Fills -->
                                    <circle data-async class="circle step2" cx="111.25" cy="26.5" r="4" />
                                    <circle class="circle step2" cx="155.25" cy="75.99" r="4" />
                                    <!-- Step 3 -->
                                    <!-- Connectors -->
                                    <path data-async class="line" d="M152.44 73.14L113.89 29.5" />
                                    <path data-async class="line" d="M155.25 71.99l-7.5-54.49" />
                                    <path data-async class="line" d="M158.18 78.71l34.13 33.41" />
                                    <path class="line" d="M43.97 213.54l67.78-25.53" />
                                    <!-- Node Outlines -->
                                    <circle data-async class="line" cx="147.75" cy="13.5" r="4.25" />
                                    <circle data-async class="line" cx="195.08" cy="115" r="4.25" />
                                    <circle class="line" cx="115.75" cy="186.5" r="4.25" />
                                    <!-- Node Fills -->
                                    <circle data-async class="circle step3" cx="147.75" cy="13.5" r="4" />
                                    <circle data-async class="circle step3" cx="195.08" cy="115" r="4" />
                                    <circle data-async class="circle step3" cx="115.75" cy="186.5" r="4" />
                                    <!-- Step 4 -->
                                    <!-- Connectors -->
                                    <path data-async class="line" d="M195.77 111.06l9.29-53.12" />
                                    <path data-async class="line" d="M197.84 117.9l38.66 40.7" />
                                    <path data-async class="line" d="M119.69 185.82l53.56-8.67" />
                                    <path class="line" d="M118.46 189.43l96.11 94.43" />
                                    <!-- Node Outlines -->
                                    <circle data-async class="line" cx="205.75" cy="54" r="4.25" />
                                    <circle data-async class="line" cx="239.25" cy="161.5" r="4.25" />
                                    <circle data-async class="line" cx="177.25" cy="176.5" r="4.25" />
                                    <circle class="line" cx="217.42" cy="286.67" r="4.25" />
                                    <!-- Node Fills -->
                                    <circle data-async class="circle step4" cx="205.75" cy="54" r="4" />
                                    <circle data-async class="circle step4" cx="239.25" cy="161.5" r="4" />
                                    <circle data-async class="circle step4" cx="177.25" cy="176.5" r="4" />
                                    <circle class="circle step4" cx="217.42" cy="286.67" r="4" />
                                    <!-- Step 5 -->
                                    <!-- Connectors -->
                                    <path data-async class="line" d="M235.46 162.78l-54.21 12.78" />
                                    <path data-async class="line" d="M237 164.81l-36.21 47.1" />
                                    <path class="line" d="M179.12 180.03l17.33 31.4" />
                                    <!-- Node Outlines -->
                                    <circle class="line" cx="198.25" cy="215" r="4.25" />
                                    <!-- Node Fills -->
                                    <circle class="circle step5" cx="198.25" cy="215" r="4" />
                                </svg>
                            </div>
                        </div>

                        <!-- Row 2: File Input -->
                        <div class="header-row header-row-2">
                            <div class="file-upload-container">
                                <label for="csvFileInput">
                                    <i class="fa-solid fa-file-arrow-up"></i></p>Choose File
                                </label>
                                <input type="file" id="csvFileInput" accept=".csv">
                                <span id="fileName" class="file-name">No file selected</span>
                            </div>
                        </div>

                        <!-- Row 3: Switch Button -->
                        <div class="header-row header-row-3">
                            <div class="switch-button-container">
                                <button id="toggleModeButton" class="btn graph-mode" disabled>
                                    <span class="btn-text"><i class="fa-solid fa-map-location-dot"></i> Switch to
                                        Map</span>
                                </button>
                            </div>
                        </div>

                    </div>
                </div>
                <!-- BOTTOM SECTION: Scrollable content -->
                <div class="col1-bottom">
                    <details class="collapsible-section" open>
                        <summary>
                            <span class="header-text"><i class="fa-solid fa-chart-simple"></i> Statistics</span>
                        </summary>
                        <div class="section-content">
                            <div id="networkStats" class="panel"></div>
                        </div>
                    </details>
                    <details class="collapsible-section" open>
                        <summary>
                            <span class="header-text"><i class="fa-solid fa-arrows-to-dot"></i> Hotspots</span>
                        </summary>
                        <div class="section-content">
                            <div id="topMetrics"></div>
                        </div>
                    </details>
                    <details class="collapsible-section" open>
                        <summary>
                            <span class="header-text"><i class="fa-solid fa-circle-nodes"></i> Trade Clusters</span>
                        </summary>
                        <div class="section-content">
                            <div id="sccOutput" class="panel"></div>
                        </div>
                    </details>
                </div>
            </div>
        </div>

        <!-- Middle Column: Graph/Map -->
        <div id="col2">
            <svg></svg>
        </div>

        <!-- Right Column: Trade Table -->
        <div id="col3">
            <div id="tradeInfo">
                <div id="tradePanel" class="panel"></div>
                <p></p>
                <div id="inArboContainer" class="panel">
                    <h4>
                        <i class="fa-solid fa-sitemap"></i> Major Import Structure
                        <span class="info-container">
                            <i class="fa-solid fa-circle-question"></i>
                            <span class="info-box">
                                In a trade network, "major import structure" is an "in-arborescence", which is a
                                directed tree where each node (except the root) has exactly one major incoming route,
                                showing how livestocks flow (mainly) inward toward the chosen root region.
                            </span>
                        </span>
                    </h4>
                    <svg id="inArboSVG"></svg>
                </div>
            </div>
        </div>
    </div>
    </div>

    <script>
        // ---- Global Variables ----
        const svg = d3.select("#col2 svg");
        let containerCol2 = document.getElementById("col2");
        let w = containerCol2.clientWidth, h = containerCol2.clientHeight;
        svg.attr("viewBox", `0 0 ${w} ${h}`);
        let currentMode = "graph";
        let nlMapData = null, nlLabelPoints = null;
        let forceSim = null, linkSelection, nodeEnter, labelSelection;
        let allLinks = [], allNodes = [];
        let selectedNodeData = null, selectedNodeBubble = null;
        let hotspots = null;
        const hotspotColors = {
            inDegree: "#08FF08",   // Fluorescent Green
            outDegree: "#05C3DD",  // Aqua Blue
            betweenness: "#ff007f", // Bright Pink
            pageRank: "#FFD600"    // Vivid Yellow
        };



        // ---- Load GeoJSON Files ----
        d3.json("assets/files/herdlink/nl_corop.geojson").then(data => { nlMapData = data; })
            .catch(error => { console.error("Error loading nl_corop.geojson:", error); });
        d3.json("assets/files/herdlink/nl_corop_labelpoint.geojson").then(data => { nlLabelPoints = data; })
            .catch(error => { console.error("Error loading nl_corop_labelpoint.geojson:", error); });

        // ---- Define Arrow Marker ----
        svg.append("defs").append("marker")
            .attr("id", "arrow")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 15)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "#fafceb");

        // ---- Disable mode toggle button initially ----
        d3.select("#toggleModeButton").attr("disabled", true);

        // ---- Toggle Button Event ----
        d3.select("#toggleModeButton").on("click", () => {
            if (currentMode === "graph") {
                switchToMapMode();
                d3.select("#toggleModeButton")
                    .html('<span class="btn-text"><i class="fa-solid fa-hexagon-nodes"></i> Switch to Graph</span>')
                    .classed("map-mode", true)
                    .classed("graph-mode", false);
                currentMode = "map";
            } else {
                switchToGraphMode();
                d3.select("#toggleModeButton")
                    .html('<span class="btn-text"><i class="fa-solid fa-map-location-dot"></i> Switch to Map</span>')
                    .classed("graph-mode", true)
                    .classed("map-mode", false);
                currentMode = "graph";
            }
        });

        // ---- Helper: Map COROP Code to statnaam ----
        function getStatnaam(code) {
            if (nlLabelPoints && nlLabelPoints.features) {
                let feat = nlLabelPoints.features.find(f => f.properties.statcode === code);
                return feat ? feat.properties.statnaam : code;
            }
            return code;
        }

        function updateNetworkStats(nodes, links) {
            const totalNodes = nodes.length,
                totalEdges = links.length,
                totalTradeVolume = d3.sum(links, d => d.weight),
                avgTradeEdge = totalEdges > 0 ? (totalTradeVolume / totalEdges).toFixed(2) : 0,
                avgTradeNode = totalNodes > 0 ? (d3.sum(nodes, d => d.tradeTotal) / totalNodes).toFixed(2) : 0;

            // Compute connectivity: how many connected components (undirected) exist?
            const numComponents = getNumberOfConnectedComponents(nodes, links);

            // Compute (or approximate) modularity by first detecting communities
            let { partition, modularity } = computeModularity(nodes, links);

            let html = `
                        <div class="stats-container">
                            <div class="stat-item">
                            <span class="stat-label">COROP Areas</span>
                            <span class="stat-value">${totalNodes}</span>
                            </div>
                            <div class="stat-item">
                            <span class="stat-label">Trade Routes</span>
                            <span class="stat-value">${totalEdges}</span>
                            </div>
                            <div class="stat-item">
                            <span class="stat-label">Total Volume</span>
                            <span class="stat-value">${totalTradeVolume}</span>
                            </div>
                            <div class="stat-item">
                            <span class="stat-label">Avg. Volume/Route</span>
                            <span class="stat-value">${avgTradeEdge}</span>
                            </div>
                            <div class="stat-item">
                            <span class="stat-label">Avg. Volume/Area</span>
                            <span class="stat-value">${avgTradeNode}</span>
                            </div>
                            <div class="stat-item">
                            <span class="stat-label">Connected Components
                                <span class="info-container">
                                    <i class="fa-solid fa-circle-question"></i>
                                    <span class="info-box">
                                        Count of “connected components” in the network. A “connected component” is a set of nodes where each node is reachable from any other node in that set (via some path of edges). Therefore, the number of connected components is a measure of how fragmented the network is.
                                    </span>
                                </span>
                            </span>
                            <span class="stat-value">${numComponents}</span>
                            </div>
                            <div class="stat-item">
                            <span class="stat-label">Modularity
                                <span class="info-container">
                                    <i class="fa-solid fa-circle-question"></i>
                                    <span class="info-box">
                                        "Modularity" measures the strength of community structure in a network. It compares the actual density of links within communities to a random network. Higher modularity value (0 to 1) indicates well-separated, strongly connected communities, while lower value suggests weaker or no community structure.
                                    </span>
                                </span>
                            </span>
                            <span class="stat-value">${modularity.toFixed(0)}</span>
                            </div>
                        </div>`;

            document.getElementById("networkStats").innerHTML = html;

            attachInfoBoxListeners();
        }

        /**
         * getNumberOfConnectedComponents(nodes, links)
         * Treats links as undirected, returns how many connected components are in the graph.
         */
        function getNumberOfConnectedComponents(nodes, links) {
            // Build an undirected adjacency list
            const adjList = {};
            nodes.forEach(n => { adjList[n.id] = new Set(); });

            links.forEach(e => {
                // Note: if e.source or e.target is an object, use e.source.id, e.target.id
                const s = (typeof e.source === "object") ? e.source.id : e.source;
                const t = (typeof e.target === "object") ? e.target.id : e.target;
                // add each direction for undirected
                adjList[s].add(t);
                adjList[t].add(s);
            });

            // BFS or DFS to count components
            let visited = new Set();
            let componentCount = 0;

            function bfs(startId) {
                let queue = [startId];
                visited.add(startId);
                while (queue.length > 0) {
                    let curr = queue.shift();
                    adjList[curr].forEach(neighborId => {
                        if (!visited.has(neighborId)) {
                            visited.add(neighborId);
                            queue.push(neighborId);
                        }
                    });
                }
            }

            // For each node, if not visited, BFS from it => found a new component
            nodes.forEach(n => {
                if (!visited.has(n.id)) {
                    componentCount++;
                    bfs(n.id);
                }
            });

            return componentCount;
        }

        function computeModularity(nodes, links) {
            // Build an array of [sourceId, targetId, weight].
            let edgesForLouvain = [];
            links.forEach(link => {
                let s = (typeof link.source === "object") ? link.source.id : link.source;
                let t = (typeof link.target === "object") ? link.target.id : link.target;
                let w = link.weight;
                // For an undirected approach, add just once.
                edgesForLouvain.push([s, t, w]);
            });

            let nodeIds = nodes.map(n => n.id);

            // Now pass an array to .edges(...)
            let community = jLouvain()
                .nodes(nodeIds)
                .edges(edgesForLouvain);

            // Run the algorithm
            let results = community();    // node => community
            let assignments = results['communities']
            let modularity = results['modularity'];

            var max_community_number = 0;
            nodeIds.forEach(function (d) {
                nodes.find(function (n) {
                    return n.id == d;
                }).community = assignments[d];
                max_community_number = max_community_number < assignments[d] ?
                    assignments[d] : max_community_number;
            });

            return {
                partition: assignments,
                modularity: modularity
            };
        }

        /**
         * computeHotSpotMetrics(allNodes, allLinks)
         *
         * For each node, computes:
         *  1) Weighted In-Degree
         *  2) Weighted Out-Degree
         *  3) Weighted Betweenness Centrality (using a simplified Brandes approach)
         *  4) Weighted PageRank (iterative approach)
         *
         * Returns an object: {
         *    [nodeId]: {
         *       inDegree: Number,
         *       outDegree: Number,
         *       betweenness: Number,
         *       pageRank: Number
         *    },
         *    ...
         * }
         *
         * allNodes: array of { id, ... }
         * allLinks: array of { source, target, weight }
         */
        function computeHotSpotMetrics(allNodes, allLinks) {
            //////////////////////////////////////////////
            // 1) Weighted In-Degree & Out-Degree
            //////////////////////////////////////////////
            const metrics = {};
            allNodes.forEach(n => {
                metrics[n.id] = {
                    inDegree: 0,
                    outDegree: 0,
                    betweenness: 0,
                    pageRank: 1, // initial PR guess
                };
            });

            // Weighted in/out-degree is just sum of "weight" on incoming/outgoing edges
            allLinks.forEach(link => {
                const s = (typeof link.source === "object") ? link.source.id : link.source;
                const t = (typeof link.target === "object") ? link.target.id : link.target;
                const w = link.weight || 1;
                if (metrics[s]) {
                    metrics[s].outDegree += w;
                }
                if (metrics[t]) {
                    metrics[t].inDegree += w;
                }
            });

            //////////////////////////////////////////////
            // 2) Weighted Betweenness Centrality
            //    (Simplified Brandes approach)
            //////////////////////////////////////////////
            // NOTE: A simplified approach that uses 1/weight as the "cost."
            //////////////////////////////////////////////

            // Build adjacency for a weighted directed graph
            const adj = {};
            allNodes.forEach(n => { adj[n.id] = []; });
            allLinks.forEach(e => {
                const s = (typeof e.source === "object") ? e.source.id : e.source;
                const t = (typeof e.target === "object") ? e.target.id : e.target;
                const w = e.weight || 1;
                adj[s].push({ target: t, cost: 1 / w }); // cost is 1/weight
            });

            function brandesBetweenness() {
                allNodes.forEach(n => {
                    metrics[n.id].betweenness = 0;
                });

                // For each node s:
                allNodes.forEach(sNode => {
                    const s = sNode.id;
                    // S: stack, P: predecessors, sigma: # of shortest paths, dist: distance
                    let S = [];
                    let P = {};
                    let sigma = {};
                    let dist = {};
                    let delta = {};
                    allNodes.forEach(n => {
                        P[n.id] = [];
                        sigma[n.id] = 0;
                        dist[n.id] = Infinity;
                        delta[n.id] = 0;
                    });
                    sigma[s] = 1;
                    dist[s] = 0;

                    // Graph search:
                    let queue = [s];
                    while (queue.length > 0) {
                        let v = queue.shift();
                        S.push(v);
                        // Explore adjacency
                        adj[v].forEach(edge => {
                            let w = edge.target;
                            let cost = edge.cost;
                            let vwDist = dist[v] + cost;
                            if (vwDist < dist[w]) {
                                dist[w] = vwDist;
                                sigma[w] = 0;
                                P[w] = [];
                                queue.push(w);
                            }
                            if (Math.abs(vwDist - dist[w]) < 1e-9) {
                                // same shortest path => update
                                sigma[w] += sigma[v];
                                P[w].push(v);
                            }
                        });
                        // Sort queue by dist for correctness (makes it Dijkstra)
                        queue.sort((a, b) => dist[a] - dist[b]);
                    }

                    // Back-propagation
                    while (S.length > 0) {
                        let w = S.pop();
                        P[w].forEach(v => {
                            delta[v] += (sigma[v] / sigma[w]) * (1 + delta[w]);
                        });
                        if (w !== s) {
                            metrics[w].betweenness += delta[w];
                        }
                    }
                });
            }

            brandesBetweenness();

            //////////////////////////////////////////////
            // 3) Weighted PageRank (Simplified)
            //////////////////////////////////////////////
            // Iterative approach:
            // pageRank(u) = (1 - d)/N + d * Sum_over_incoming( pageRank(v) * (weight_uv / sum_of_outgoing_weights_of(v)) )
            // d ~ 0.85
            //////////////////////////////////////////////

            let d = 0.85;
            let N = allNodes.length;
            // Precompute outWeight sums to do Weighted PR
            let outWeightSum = {};
            allNodes.forEach(n => {
                outWeightSum[n.id] = 0;
            });
            allLinks.forEach(link => {
                const s = (typeof link.source === "object") ? link.source.id : link.source;
                const w = link.weight || 1;
                outWeightSum[s] += w;
            });

            function doPageRankIteration() {
                let newPR = {};
                allNodes.forEach(n => {
                    newPR[n.id] = (1 - d) / N;
                });

                // For each edge v->u with weight w, contribute Weighted PR fraction
                allLinks.forEach(link => {
                    let vId = (typeof link.source === "object") ? link.source.id : link.source;
                    let uId = (typeof link.target === "object") ? link.target.id : link.target;
                    let w = link.weight || 1;
                    // Weighted fraction of v's PR
                    if (outWeightSum[vId] > 0) {
                        let contrib = d * (metrics[vId].pageRank * (w / outWeightSum[vId]));
                        newPR[uId] += contrib;
                    }
                });

                // Overwrite
                allNodes.forEach(n => {
                    metrics[n.id].pageRank = newPR[n.id];
                });
            }

            // run 20 iterations
            for (let i = 0; i < 20; i++) {
                doPageRankIteration();
            }

            //////////////////////////////////////////////
            // Return final metrics
            //////////////////////////////////////////////
            return metrics;
        }

        // ---- Helper: Adjust Arrow Endpoint ----
        function getAdjustedTarget(d) {
            let dx = d.target.x - d.source.x,
                dy = d.target.y - d.source.y,
                dist = Math.sqrt(dx * dx + dy * dy);
            if (dist === 0) return { x: d.target.x, y: d.target.y };
            return { x: d.target.x - (dx / dist) * d.target.r, y: d.target.y - (dy / dist) * d.target.r };
        }

        /**
         * printHotSpots(metrics, containerId)
         *
         * Creates multiple sub-tables, one per metric (inDegree, outDegree, betweenness, pageRank).
         * Each sub-table lists the nodes in descending order of that metric.
         * 
         * Layout example:
         *   <h4>inDegree</h4>
         *   <table>
         *     <tr><th>Node</th><th>inDegree</th></tr>
         *     <tr><td>A</td><td>30.00</td></tr>
         *     ...
         *   </table>
         *
         * @param {Object} metrics - e.g. {
         *     "A": { inDegree: 10, outDegree: 20, betweenness: 5.3, pageRank: 0.12 },
         *     "B": { inDegree: 12, outDegree: 9,  betweenness: 3.8, pageRank: 0.20 },
         *   }
         * @param {String} containerId - e.g. "topMetrics"
         * @param {Number} n - Number of top nodes per metric to display
         */
        function printHotSpots(metrics, containerId, n) {
            const container = document.getElementById(containerId);
            if (!container) {
                console.warn("No container found for ID:", containerId);
                return;
            }

            // Clear the container
            container.innerHTML = "";

            const metricNames = ["inDegree", "outDegree", "betweenness", "pageRank"];

            // Mapping from metricNames to display names
            const metricDisplayNames = {
                inDegree: "Vulnerable (by In-Degree)",
                outDegree: "Seeding (by Out-Degree)",
                betweenness: "Gateway (by Betweenness)",
                pageRank: "Bottleneck (by PageRank)"
            };

            // Helper: sort all nodes by the specified metric (descending)
            function sortByMetric(metricName) {
                const arr = Object.keys(metrics).map(nodeId => ({
                    nodeId,
                    value: metrics[nodeId][metricName] || 0
                }));
                arr.sort((a, b) => b.value - a.value); // descending
                return arr;
            }

            // For each metric, show top N items
            metricNames.forEach(metricName => {
                const sortedList = sortByMetric(metricName);
                if (n) sortedList.splice(n); // keep only top N

                let subHtml = `
                <details class="collapsible-subsection" open>
                <summary class="hotspot-section-header">${metricDisplayNames[metricName]}</summary>
            `;

                // Add each hotspot as a row-like item
                sortedList.forEach(item => {
                    subHtml += `
                    <div class="hotspot-item">
                    <span class="hotspot-area">${item.nodeId}</span>
                    <span class="hotspot-value">${item.value.toFixed(2)}</span>
                    </div>
                `;
                });

                subHtml += `
                </details>
            `;

                container.innerHTML += subHtml;
            });
        }

        // ---- Create Network ----
        function createNetwork(nodes, links) {
            // Use a log scale for edge colors.
            const edgeExtent = d3.extent(links, d => Math.log(d.weight));
            const edgeColor = d3.scaleSequential(d3.interpolateSpectral)
                .domain([edgeExtent[1], edgeExtent[0]]);
            const nodeColor = d3.scaleOrdinal(d3.schemeCategory10);
            const nodeSize = d3.scaleSqrt()
                .domain(d3.extent(nodes, d => d.tradeTotal))
                .range([5, 20]);

            forceSim = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(150))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(w / 2, h / 2));

            const linkGroup = svg.append("g").attr("class", "links");
            linkSelection = linkGroup.selectAll("path")
                .data(links)
                .enter().append("path")
                .attr("class", "link")
                .attr("stroke", d => edgeColor(Math.log(d.weight)))
                .attr("stroke-width", d => Math.sqrt(d.weight));

            const nodeGroup = svg.append("g").attr("class", "nodes");

            // Compute top-3 lists for each metric from the hotspots object.
            const metricNames = ["inDegree", "outDegree", "betweenness", "pageRank"];
            let top3ForMetric = {};
            metricNames.forEach(metric => {
                // Sort the keys (node IDs) of hotspots by descending metric value.
                top3ForMetric[metric] = Object.keys(hotspots)
                    .sort((a, b) => hotspots[b][metric] - hotspots[a][metric])
                    .slice(0, 3);
            });

            // Create a group for each node (will contain circle, hotspot strokes, and label)
            nodeEnter = nodeGroup.selectAll(".nodeGroup")
                .data(nodes)
                .enter().append("g")
                .attr("class", "nodeGroup")
                .call(drag(forceSim))
                .on("click", onClickNode)
                .on("mouseover", function (event, d) {
                    d3.select(this).raise();
                    d3.select(this).select("circle.primary")
                        .attr("stroke", "black");
                    const tooltipDiv = d3.select("#tooltip");
                    tooltipDiv.style("opacity", 1)
                        .html(`${d.id} ${d.statnaam} (Trade: ${d.tradeTotal})`);
                })
                .on("mousemove", function (event, d) {
                    d3.select("#tooltip")
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY + 10) + "px");
                })
                .on("mouseout", function (event, d) {
                    d3.select(this).select("circle.primary")
                        .attr("stroke", null)
                        .attr("stroke-width", null);
                    d3.select("#tooltip").style("opacity", 0);
                });

            // Append primary node circle.
            nodeEnter.append("circle")
                .attr("class", "primary")
                .attr("r", d => { d.r = nodeSize(d.tradeTotal); return d.r; })
                .attr("fill", d => {
                    let cid = d.community;
                    return nodeColor(cid);
                })
                .attr("stroke", null)
                .attr("stroke-width", null);

            // Append extra hotspot strokes based on top3ForMetric.
            nodeEnter.each(function (d) {
                let metricsForNode = [];
                metricNames.forEach(metric => {
                    // If this node is in the top-3 for the metric, add it.
                    if (top3ForMetric[metric].includes(d.id)) {
                        metricsForNode.push(metric);
                    }
                });
                metricsForNode.sort();
                let group = d3.select(this);
                metricsForNode.forEach((metric, i) => {
                    group.append("circle")
                        .attr("class", "hotspotStroke")
                        .attr("r", d.r + (i + 1) * 3) // each extra ring offset by 3px per metric
                        .attr("fill", "none")
                        .attr("stroke", hotspotColors[metric])
                        .attr("stroke-width", 2)
                        .attr("stroke-dashoffset", 0);
                });
            });

            // Append text labels for nodes.
            labelSelection = nodeGroup.selectAll(".nodeLabel")
                .data(nodes)
                .enter().append("text")
                .attr("class", "nodeLabel")
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .attr("fill", "black")
                .text(d => d.id);

            forceSim.on("tick", () => {
                if (currentMode === "graph") {
                    linkSelection.attr("d", function (d) {
                        const dx = d.target.x - d.source.x,
                            dy = d.target.y - d.source.y,
                            dr = Math.sqrt(dx * dx + dy * dy),
                            adj = getAdjustedTarget(d);
                        return "M" + d.source.x + "," + d.source.y +
                            "A" + dr + "," + dr + " 0 0,1 " + adj.x + "," + adj.y;
                    });
                    // Update positions of the node groups (circle + hotspot strokes)
                    nodeEnter.attr("transform", d => `translate(${d.x},${d.y})`);
                    // Update text labels positions.
                    labelSelection
                        .attr("x", d => d.x)
                        .attr("y", d => d.y - (d.r + 13));
                    if (currentMode === "graph" && selectedNodeBubble && selectedNodeData) {
                        selectedNodeBubble.attr("transform", "translate(" + selectedNodeData.x + "," + (selectedNodeData.y - 20) + ")");
                    }
                }
            });

            linkSelection
                .on("mouseover", function (event, d) {
                    if (d3.select(this).classed("linkSelect")) {
                        d3.select(this).attr("class", "linkSelectOver").raise();
                    } else {
                        d3.select(this).attr("class", "linkOver").raise();
                    }
                    const tooltipDiv = d3.select("#tooltip");
                    tooltipDiv.style("opacity", 1)
                        .html(`${d.source.id} ${getStatnaam((typeof d.source === "object" ? d.source.id : d.source))} → ${d.target.id} ${getStatnaam((typeof d.target === "object" ? d.target.id : d.target))}: ${d.weight}`);
                })
                .on("mousemove", function (event, d) {
                    d3.select("#tooltip")
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY + 10) + "px");
                })
                .on("mouseout", function (event, d) {
                    if (d3.select(this).classed("linkSelectOver")) {
                        d3.select(this).attr("class", "linkSelect");
                    } else {
                        d3.select(this).attr("class", "link");
                    }
                    d3.select("#tooltip").style("opacity", 0);
                });

            // ---- Add Hotspot Stroke Legend ----
            addHotspotLegend(svg);

            // ---- Define Edge Glow Filter ----
            const defs = svg.append("defs");
            const edgeGlow = defs.append("filter")
                .attr("id", "edgeGlow")
                .attr("x", "-50%")
                .attr("y", "-50%")
                .attr("width", "200%")
                .attr("height", "200%");

            edgeGlow.append("feGaussianBlur")
                .attr("in", "SourceGraphic")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            const feMerge = edgeGlow.append("feMerge");
            feMerge.append("feMergeNode")
                .attr("in", "blur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");
        }

        function addHotspotLegend(svg) {
            const legendWidth = w / 3;

            const margin = { top: 50, right: 50, bottom: 50, left: 50 };

            const legendData = [
                { name: "Vulnerable", color: hotspotColors.inDegree },
                { name: "Seeding", color: hotspotColors.outDegree },
                { name: "Gateway", color: hotspotColors.betweenness },
                { name: "Bottleneck", color: hotspotColors.pageRank }
            ];

            const legend = svg.append("g")
                .attr("class", "hotspotLegend")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);

            const legendItem = legend.selectAll(".legendItem")
                .data(legendData)
                .enter().append("g")
                .attr("class", "legendItem")
                .attr("transform", (d, i) => `translate(${margin.left}, ${margin.top + i * 25})`);

            legendItem.append("circle")
                .attr("r", 10)
                .attr("fill", "none")
                .attr("stroke", d => d.color)
                .attr("stroke-width", 3)
                .attr("stroke-dasharray", "5 5")
                .attr("stroke-dashoffset", 0);

            legendItem.append("text")
                .attr("x", 25)
                .attr("y", 7)
                .attr("font-size", "18px")
                .attr("fill", "black")
                .text(d => d.name);
        }

        // ---- Node Click Handler ----
        function onClickNode(event, d) {
            if (event.defaultPrevented) return;
            // Save previous selection before clearing
            let wasSelected = !!selectedNodeData;
            let wasSameNode = selectedNodeData && selectedNodeData.id === d.id;
            // If clicking the same node, clear selection and return.
            if (wasSameNode) {
                clearSelection(false);
                return;
            }
            clearSelection(wasSelected && !wasSameNode);
            selectedNodeData = d;
            if (currentMode === "graph") {
                selectedNodeBubble = svg.append("g")
                    .attr("class", "bubble")
                    .attr("pointer-events", "none");
                let bubbleText = selectedNodeBubble.append("text")
                    .attr("text-anchor", "middle")
                    .attr("dy", "0.3em")
                    .text(d.statnaam);
                const bbox = bubbleText.node().getBBox();
                selectedNodeBubble.insert("rect", "text")
                    .attr("x", bbox.x - 4)
                    .attr("y", bbox.y - 2)
                    .attr("width", bbox.width + 8)
                    .attr("height", bbox.height + 4)
                    .attr("fill", "#fff")
                    .attr("stroke", "#000")
                    .attr("rx", 3)
                    .attr("ry", 3);
                selectedNodeBubble.raise();
                selectedNodeBubble.attr("transform", "translate(" + d.x + "," + (d.y - 20) + ")");
            }
            // If clicked, change node labels to white
            labelSelection.attr("fill", "white");
            // If clicked, change legend text to white
            d3.selectAll(".legendItem text").attr("fill", "white");
            // If clicked, add glowing filter to legend circles
            d3.selectAll(".legendItem circle").attr("filter", "url(#edgeGlow)");
            // If clicked, add glowing filter to main figure's hotspot strokes
            d3.selectAll(".hotspotStroke").attr("filter", "url(#edgeGlow)");
            // If clicked, change link colors, add arrowheads and glowing filter
            linkSelection.attr("display", function (linkData) {
                const srcId = (typeof linkData.source === "object" ? linkData.source.id : linkData.source),
                    tgtId = (typeof linkData.target === "object" ? linkData.target.id : linkData.target);
                if (srcId === d.id) {
                    d3.select(this)
                        .attr("class", "linkSelect")
                        .attr("stroke", "#46fa46")
                        .attr("stroke-width", Math.sqrt(linkData.weight) + 2)
                        .attr("opacity", 1)
                        .attr("filter", "url(#edgeGlow)");
                    return "block";
                } else if (tgtId === d.id) {
                    d3.select(this)
                        .attr("class", "linkSelect")
                        .attr("stroke", "#fcc67e")
                        .attr("stroke-width", Math.sqrt(linkData.weight) + 2)
                        .attr("opacity", 1)
                        .attr("filter", "url(#edgeGlow)");
                    return "block";
                } else { return "none"; }
            })
                .attr("marker-end", function (linkData) {
                    const srcId = (typeof linkData.source === "object" ? linkData.source.id : linkData.source),
                        tgtId = (typeof linkData.target === "object" ? linkData.target.id : linkData.target);
                    if (srcId === d.id || tgtId === d.id) { return "url(#arrow)"; }
                    else { return null; }
                });

            // Show/Update trade table and (re)-plot in/out arborescences
            updateTradeTable(d);
            replotInOutArbos(d.id);

            // Add an overlay to gray out the background map.
            // Insert a rectangle as the first child of the SVG.
            // Add/update overlay.
            if (svg.select("#mapOverlay").empty()) {
                if (wasSelected) {
                    // If a node was already selected, do NOT animate.
                    svg.insert("rect", ":first-child")
                        .attr("id", "mapOverlay")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("width", w)
                        .attr("height", h)
                        .attr("fill", "black")
                        .attr("opacity", 0.7);
                } else {
                    // If no node was previously selected, animate the overlay.
                    svg.insert("rect", ":first-child")
                        .attr("id", "mapOverlay")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("width", w)
                        .attr("height", h)
                        .attr("fill", "black")
                        .attr("opacity", 0)
                        .transition()
                        .duration(300)
                        .attr("opacity", 0.7);
                }
            }
            // Unhide the trade information panel
            document.getElementById("tradeInfo").style.display = "block";
        }

        // ---- Clear Selection (If Clicking Again/Unclicked) ----
        function clearSelection(flag) {
            if (selectedNodeBubble) { selectedNodeBubble.remove(); selectedNodeBubble = null; }
            selectedNodeData = null;

            const colorScale = d3.scaleSequential(d3.interpolateSpectral)
                .domain(d3.extent(allLinks, d => Math.log(d.weight)).reverse()); // Inverted color scale

            // If unclicked, change node labels back to black
            labelSelection.attr("fill", "black");
            // If unclicked, change legend text back to black
            d3.selectAll(".legendItem text").attr("fill", "black");
            // If unclicked, remove glowing filter from legend circles
            d3.selectAll(".legendItem circle").attr("filter", null);
            // If unclicked, remove glowing filter from main figure's hotspot strokes
            d3.selectAll(".hotspotStroke").attr("filter", null);
            // If unclicked, change link colors back, remove arrowheads and glowing filter
            linkSelection.attr("display", "block")
                .attr("class", "link")
                .attr("marker-end", null)
                .attr("stroke", d => colorScale(Math.log(d.weight))) // Use the inverted scale
                .attr("stroke-width", d => Math.sqrt(d.weight))
                .attr("opacity", 0.5)
                .attr("filter", null);

            // Clear the trade table and arborescences
            updateTradeTable(null);
            replotInOutArbos(null);

            // Hide the trade information panel
            document.getElementById("tradeInfo").style.display = "none";

            // Remove the background overlay if select another node
            if (!flag) {
                svg.select("#mapOverlay").transition().duration(300).attr("opacity", 0).remove();
            } else {
                svg.select("#mapOverlay").remove();
            }
        }

        // ---- Update Trade Table ----
        function updateTradeTable(selectedNode) {
            const tradePanelDiv = document.getElementById("tradePanel");
            if (!selectedNode) {
                tradePanelDiv.innerHTML = "";
                return;
            }

            // Filter outgoing and incoming links
            const outgoing = allLinks.filter(d =>
                (typeof d.source === "object" ? d.source.id : d.source) === selectedNode.id
            );
            const incoming = allLinks.filter(d =>
                (typeof d.target === "object" ? d.target.id : d.target) === selectedNode.id
            );

            // Sort descending by weight
            outgoing.sort((a, b) => b.weight - a.weight);
            incoming.sort((a, b) => b.weight - a.weight);

            let html = `
                        <div class="trade-info-header">
                            <h4><i class="fa-solid fa-location-dot"></i> ${selectedNode.statnaam} [${selectedNode.id}] </h4>
                        </div>
                        <div class="trade-sections d-flex gap-3">
                            
                            <!-- Outgoing trades section -->
                            <div class="trade-section flex-fill">
                            <div class="trade-section-header"><i class="fa-solid fa-arrow-right-from-bracket"></i> Outgoing Trades</div>
                            <div class="trade-list" style="max-height: 17vh; overflow-y: auto;">
                        `;

            if (outgoing.length > 0) {
                outgoing.forEach(trade => {
                    const dest = getStatnaam((typeof trade.target === "object" ? trade.target.id : trade.target));
                    html += `
                            <div class="trade-item d-flex justify-content-between">
                                <span class="trade-dest">${dest}</span>
                                <span class="trade-volume">${trade.weight}</span>
                            </div>
                            `;
                });
            } else {
                html += `<div class="trade-item no-trades">No outgoing trades.</div>`;
            }

            html += `
                        </div> <!-- .trade-list -->
                        </div> <!-- .trade-section -->

                        <!-- Incoming trades section -->
                        <div class="trade-section flex-fill">
                        <div class="trade-section-header"><i class="fa-solid fa-arrow-right-to-bracket"></i> Incoming Trades</div>
                        <div class="trade-list" style="max-height: 17vh; overflow-y: auto;">
                    `;

            if (incoming.length > 0) {
                incoming.forEach(trade => {
                    const src = getStatnaam((typeof trade.source === "object" ? trade.source.id : trade.source));
                    html += `
                            <div class="trade-item d-flex justify-content-between">
                                <span class="trade-src">${src}</span>
                                <span class="trade-volume">${trade.weight}</span>
                            </div>
                            `;
                });
            } else {
                html += `<div class="trade-item no-trades">No incoming trades.</div>`;
            }

            html += `
                        </div> <!-- .trade-list -->
                        </div> <!-- .trade-section -->

                    </div> <!-- .trade-sections -->
                    `;

            // Inject the final HTML
            tradePanelDiv.innerHTML = html;
        }

        // ---- Force Simulation Drag Handler ----
        function drag(simulation) {
            function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
            function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
            function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }
            return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
        }

        // ---- Functions to switch between graph and map mode ----
        function switchToMapMode() {
            if (forceSim) forceSim.stop();
            if (!nlMapData) { console.error("NL map data not loaded."); return; }
            const projection = d3.geoIdentity().reflectY(true).fitSize([w, h], nlMapData);
            const path = d3.geoPath().projection(projection);
            const mapLayer = svg.insert("g", ":first-child").attr("class", "map");
            mapLayer.selectAll("path")
                .data(nlMapData.features)
                .enter().append("path")
                .attr("d", path)
                .attr("fill", "none")
                .attr("stroke", "#999");
            if (!svg.select("#mapOverlay").empty()) {
                svg.select("#mapOverlay").remove();
                svg.insert("rect", ":first-child")
                    .attr("id", "mapOverlay")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", w)
                    .attr("height", h)
                    .attr("fill", "black")
                    .attr("opacity", 0.7);
            }
            if (!nlLabelPoints) { console.error("NL label point data not loaded."); }
            else {
                nodeEnter.each(function (d) {
                    const labelFeature = nlLabelPoints.features.find(f => f.properties.statcode === d.id);
                    if (labelFeature) {
                        const coords = projection(labelFeature.geometry.coordinates);
                        d.x = coords[0];
                        d.y = coords[1];
                    }
                });
            }
            updateMapPositionsWithTransition();
        }

        function switchToGraphMode() {
            svg.selectAll(".map").remove();
            nodeEnter.each(function (d) { d.fx = null; d.fy = null; });
            if (forceSim) { forceSim.alpha(1).restart(); }
        }

        // ---- Update Node Positions When Switching to Map Mode ----
        function updateMapPositionsWithTransition() {
            nodeEnter.transition().duration(1000)
                .attr("transform", d => `translate(${d.x},${d.y})`);

            linkSelection.transition().duration(1000)
                .attr("d", function (d) {
                    const dx = d.target.x - d.source.x,
                        dy = d.target.y - d.source.y,
                        dr = Math.sqrt(dx * dx + dy * dy),
                        adj = getAdjustedTarget(d);
                    return "M" + d.source.x + "," + d.source.y +
                        "A" + dr + "," + dr + " 0 0,1 " + adj.x + "," + adj.y;
                });

            labelSelection.transition().duration(1000)
                .attr("x", d => d.x)
                .attr("y", d => d.y - (d.r + 13));
        }

        /**
         * chuLiuEdmonds(nodes, edges, root, direction)
         * 
         * Computes a maximum spanning arborescence using a simplified Chu-Liu/Edmonds approach.
         * 
         * @param {Array} nodes - Array of node objects, each with at least {id: string}.
         * @param {Array} edges - Array of edge objects, each with {source, target, weight}.
         *                        source/target can be either a node object or an ID string.
         * @param {Object} root - The root node object for the arborescence, e.g. {id: "Root"}
         * @param {String} direction - "in" or "out".
         *    - "in":   each node except root has exactly one incoming edge (a standard in-arborescence).
         *    - "out":  each node except root has exactly one outgoing edge (equivalent to reversing edges, 
         *              computing an in-arbo, then reversing them back).
         * @returns {Array} an array of edges ( {source, target, weight} ) forming the maximum arborescence.
         */
        function chuLiuEdmonds(nodes, edges, root, direction) {
            // If OUT-arborescence, reverse edges first.
            let reversed = false;
            let workingEdges = edges;
            if (direction === "out") {
                reversed = true;
                workingEdges = edges.map(e => ({
                    source: e.target,
                    target: e.source,
                    weight: e.weight
                }));
            }

            // ---------------------------
            // Step 1: For each node (except root), pick the single incoming edge of maximum weight
            //         in the (possibly reversed) graph
            // ---------------------------
            let inEdges = {};
            nodes.forEach(node => {
                if (node.id === root.id) return;
                // all edges that lead *into* this node
                const incoming = workingEdges.filter(e => {
                    const t = (typeof e.target === "object") ? e.target.id : e.target;
                    return t === node.id;
                });
                if (incoming.length > 0) {
                    // pick the heaviest edge
                    inEdges[node.id] = incoming.reduce((a, b) => a.weight > b.weight ? a : b);
                }
            });

            // ---------------------------
            // Step 2: Detect a cycle by DFS
            // ---------------------------
            let cycle = null;
            let visited = {};

            // DFS to detect a cycle
            function dfsCycle(nodeId, path) {
                if (visited[nodeId]) {
                    // if visited before in the current path, then there's a cycle
                    const idx = path.indexOf(nodeId);
                    if (idx !== -1) {
                        cycle = path.slice(idx);
                    }
                    return;
                }
                visited[nodeId] = true;
                if (inEdges[nodeId]) {
                    // follow the one incoming edge
                    const src = (typeof inEdges[nodeId].source === "object")
                        ? inEdges[nodeId].source.id
                        : inEdges[nodeId].source;
                    dfsCycle(src, path.concat([nodeId]));
                }
            }

            // run DFS for each node except root
            nodes.forEach(node => {
                if (node.id !== root.id && !visited[node.id]) {
                    dfsCycle(node.id, []);
                }
            });

            // if there's no cycle, there's a valid arborescence
            if (!cycle) {
                // collecting all the inEdges values is enough to define the arborescence
                let result = Object.values(inEdges);

                // if reversed edges for "out", should also reverse the result back
                if (reversed) {
                    result = result.map(e => ({
                        source: e.target,
                        target: e.source,
                        weight: e.weight
                    }));
                }
                return result;
            }

            // ---------------------------
            // Step 3: Contract the cycle
            // ---------------------------
            // create a synthetic node ID for the entire cycle
            let cycleId = cycle.join("_");

            // remove cycle nodes from 'nodes' and add one new "contracted" node
            let contractedNodes = nodes.filter(n => !cycle.includes(n.id));
            contractedNodes.push({ id: cycleId });

            // build new edges with cycle references replaced by 'cycleId'
            let contractedEdges = [];
            for (const e of workingEdges) {
                const s = (typeof e.source === "object") ? e.source.id : e.source;
                const t = (typeof e.target === "object") ? e.target.id : e.target;
                let newS = cycle.includes(s) ? cycleId : s;
                let newT = cycle.includes(t) ? cycleId : t;

                // skip self loops
                if (newS === newT) continue;

                let newWeight = e.weight;
                // if t is in the cycle, but s is not, subtract the weight of that node's chosen edge
                if (cycle.includes(t) && !cycle.includes(s)) {
                    newWeight = e.weight - inEdges[t].weight;
                }

                contractedEdges.push({ source: newS, target: newT, weight: newWeight });
            }

            // recursively compute arbo on contracted graph
            const contractedRoot = (root.id === cycleId) ? { id: cycleId } : root;
            let T = chuLiuEdmonds(contractedNodes, contractedEdges, contractedRoot, "in");
            // ^ pass direction = "in" here

            // ---------------------------
            // Step 4: Expand the cycle
            // ---------------------------
            // find the edge pointing to the cycleId in T
            let cycleEdge = T.find(e => {
                const tid = (typeof e.target === "object") ? e.target.id : e.target;
                return tid === cycleId;
            });

            // remove that edge from T
            T = T.filter(e => {
                const tid = (typeof e.target === "object") ? e.target.id : e.target;
                return tid !== cycleId;
            });

            // restore the cycle's chosen edges
            cycle.forEach(id => {
                T.push(inEdges[id]);
            });

            // if reversed edges for "out", should also reverse the final result back
            if (reversed) {
                T = T.map(e => ({
                    source: e.target,
                    target: e.source,
                    weight: e.weight
                }));
            }

            return T;
        }

        /**
         * visualizeArborescence(treeEdges, containerSelector, rootId)
         *
         * Displays a directed arborescence in a top-down tree layout using d3.tree().
         * If 'treeEdges' is empty, shows "No arborescence found."
         *
         * @param {Array} treeEdges - Arborescence edges: {source, target, weight}
         * @param {String} containerSelector - e.g. "#inArboSVG"
         * @param {String} rootId - ID of the root node
         */
        function visualizeArborescence(treeEdges, containerSelector, rootId) {
            // 1) Clear the container
            const container = d3.select(containerSelector);
            container.selectAll("*").remove();

            // If no edges, display message
            if (!treeEdges || treeEdges.length === 0) {
                container.append("text")
                    .attr("x", 10)
                    .attr("y", 20)
                    .text("No major routes found.");
                return;
            }

            // 2) Collect node IDs from edges
            let nodeIds = new Set();
            treeEdges.forEach(e => {
                let s = (typeof e.source === "object") ? e.source.id : e.source;
                let t = (typeof e.target === "object") ? e.target.id : e.target;
                nodeIds.add(s);
                nodeIds.add(t);
            });

            // 3) Filter allNodes to only those in arbo
            let treeNodes = allNodes.filter(n => nodeIds.has(n.id));

            // 4) Build adjacency: childrenMap[parentId] = [childId1, childId2, ...]
            let childrenMap = {};
            treeNodes.forEach(n => {
                childrenMap[n.id] = [];
            });
            // Each edge is parent -> child
            treeEdges.forEach(e => {
                let s = (typeof e.source === "object") ? e.source.id : e.source;
                let t = (typeof e.target === "object") ? e.target.id : e.target;
                if (childrenMap[s]) {
                    childrenMap[s].push(t);
                }
            });

            // 5) Build a nested structure for d3.tree with 'rootId' as the root
            function buildHierarchy(nodeId) {
                return {
                    name: nodeId,
                    children: (childrenMap[nodeId] || []).map(childId => buildHierarchy(childId))
                };
            }

            // If rootId not in treeNodes, show error
            let rootNode = treeNodes.find(n => n.id === rootId);
            if (!rootNode) {
                container.append("text")
                    .attr("x", 10)
                    .attr("y", 20)
                    .text(`Root ${rootId} not found in arborescence.`);
                return;
            }

            let rootData = buildHierarchy(rootId);

            // 6) Create an <svg> inside the container
            let width = parseInt(container.style("width"), 10);
            let height = parseInt(container.style("height"), 10);

            let svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);

            // 7) Use d3.tree() for a top-down layout
            let layout = d3.tree().size([width - 40, height - 40]);

            // 8) Convert to a d3.hierarchy
            let root = d3.hierarchy(rootData, d => d.children);

            // 9) Compute node/link positions
            layout(root);
            // After layout, each node has: d.x => horizontal, d.y => vertical

            // 10) Draw edges (links)
            svg.selectAll(".link")
                .data(root.links())
                .enter()
                .append("path")
                .attr("class", "link")
                .attr("fill", "none")
                .attr("stroke", "#555")
                .attr("stroke-width", 2)
                .attr("d", d3.linkVertical()
                    .x(d => d.x + 20) // shift horizontally by 20
                    .y(d => d.y + 30) // shift vertically by 20
                );

            // 11) Draw nodes
            let nodeGroup = svg.selectAll(".node")
                .data(root.descendants())
                .enter()
                .append("g")
                .attr("class", "node")
                // place each node at (d.x, d.y), plus some offset
                .attr("transform", d => `translate(${d.x + 20},${d.y + 30})`);

            // 12) Circles for each node
            nodeGroup.append("circle")
                .attr("r", 5)
                .attr("fill", d => (d.data.name === rootId) ? "orange" : "#69b3a2");

            // 13) Labels
            nodeGroup.append("text")
                .attr("dy", -2)
                .attr("dx", 14)
                .attr("font-size", "8px")
                .attr("text-anchor", "middle")
                .attr("transform", (d) => `rotate(-45)`)
                .text(d => d.data.name);
        }


        // ---- Maximum Clique Computation with Reciprocal Edges ----
        // Only consider an undirected edge between two nodes if both A->B and B->A exist.
        function computeMaximumClique() {
            let directedEdges = new Set();
            // Record all directed edges.
            allLinks.forEach(link => {
                const s = (typeof link.source === "object") ? link.source.id : link.source;
                const t = (typeof link.target === "object") ? link.target.id : link.target;
                directedEdges.add(s + "->" + t);
            });
            // Build the undirected graph using only reciprocal edges.
            let adjList = {};
            allNodes.forEach(n => { adjList[n.id] = new Set(); });
            allLinks.forEach(link => {
                const s = (typeof link.source === "object") ? link.source.id : link.source;
                const t = (typeof link.target === "object") ? link.target.id : link.target;
                // Only add the edge if both directions exist.
                if (directedEdges.has(s + "->" + t) && directedEdges.has(t + "->" + s)) {
                    adjList[s].add(t);
                    adjList[t].add(s);
                }
            });

            let maxClique = [];

            function bronKerboschPivot(R, P, X) {
                if (P.length === 0 && X.length === 0) {
                    if (R.length > maxClique.length) {
                        maxClique = R;
                    }
                    return;
                }
                // Choose a pivot from P ∪ X.
                let pivotCandidates = P.concat(X);
                let pivot = pivotCandidates[0];
                let pivotNeighbors = adjList[pivot.id];
                // Only consider vertices in P that are not neighbors of the pivot.
                let PwithoutNeighbors = P.filter(v => !pivotNeighbors.has(v.id));
                for (let v of PwithoutNeighbors) {
                    let newR = R.concat([v]);
                    let newP = P.filter(u => adjList[v.id].has(u.id));
                    let newX = X.filter(u => adjList[v.id].has(u.id));
                    bronKerboschPivot(newR, newP, newX);
                    P = P.filter(u => u.id !== v.id);
                    X.push(v);
                }
            }

            bronKerboschPivot([], allNodes.slice(), []);
            return maxClique;
        }

        /**
         * computeMaxCliqueReciprocal()
         * 
         * Finds the maximum cardinality clique in the “undirected” subgraph formed by
         * reciprocal edges
         *
         * Returns an array of node objects forming the largest clique.
         */
        function computeMaxCliqueReciprocal() {
            // 1) Gather all directed edges into a set like "A->B"
            let directedEdges = new Set();
            allLinks.forEach(link => {
                const s = (typeof link.source === "object") ? link.source.id : link.source;
                const t = (typeof link.target === "object") ? link.target.id : link.target;
                directedEdges.add(s + "->" + t);
            });

            // 2) Build adjacency for the "undirected" subgraph (reciprocal edges only)
            let adjList = {};
            allNodes.forEach(n => {
                adjList[n.id] = new Set();
            });

            allLinks.forEach(link => {
                const s = (typeof link.source === "object") ? link.source.id : link.source;
                const t = (typeof link.target === "object") ? link.target.id : link.target;
                // Only add s<->t if s->t and t->s are both present
                if (directedEdges.has(s + "->" + t) && directedEdges.has(t + "->" + s)) {
                    adjList[s].add(t);
                    adjList[t].add(s);
                }
            });

            // 3) The Bron–Kerbosch recursive approach
            let maxClique = [];

            /**
             * bronKerboschPivot(R, P, X)
             * @param {Array} R - array of node objects currently in the clique
             * @param {Array} P - array of node objects that can still join the clique
             * @param {Array} X - array of node objects that must be excluded
             */
            function bronKerboschPivot(R, P, X) {
                // If neither P nor X has possible candidates, R is a maximal clique
                if (P.length === 0 && X.length === 0) {
                    // Update maxClique if this clique is larger
                    if (R.length > maxClique.length) {
                        // Store a copy, not a reference
                        maxClique = R.slice();
                    }
                    return;
                }

                if (P.length === 0 && X.length > 0) {
                    // There's no candidate to expand with, so it's done
                    if (R.length > maxClique.length) {
                        maxClique = R.slice();
                    }
                    return;
                }
                if (P.length + R.length <= maxClique.length) {
                    // Pruning: no chance to exceed current maximum
                    return;
                }

                // Combine P ∪ X to choose a pivot
                let pivotCandidates = P.concat(X);
                if (pivotCandidates.length === 0) {
                    // If there's no pivot, just stop
                    if (R.length > maxClique.length) {
                        maxClique = R.slice();
                    }
                    return;
                }

                // Choose a pivot arbitrarily
                let pivot = pivotCandidates[0];
                // pivotNeighbors is the set of string IDs adjacent to pivot.id
                let pivotNeighbors = adjList[pivot.id] || new Set();

                // P \ pivotNeighbors
                let PwithoutNeighbors = P.filter(v => !pivotNeighbors.has(v.id));

                for (let v of PwithoutNeighbors) {
                    // vNeighbors is the set of neighbors for node v
                    let vNeighbors = adjList[v.id] || new Set();

                    // newR = R ∪ {v}
                    let newR = R.concat([v]);

                    // newP = P ∩ N(v)
                    let newP = P.filter(u => vNeighbors.has(u.id));

                    // newX = X ∩ N(v)
                    let newX = X.filter(u => vNeighbors.has(u.id));

                    bronKerboschPivot(newR, newP, newX);

                    // Remove v from P, add to X
                    P = P.filter(u => u.id !== v.id);
                    X.push(v);
                }
            }

            // 4) Initially, R = empty, P = allNodes, X = empty
            let R = [];
            let P = allNodes.slice(); // copy all node objects
            let X = [];

            bronKerboschPivot(R, P, X);

            return maxClique;
        }

        /**
         * findSCCs(nodes, edges)
         *
         * Uses Tarjan’s Algorithm to find strongly connected components (SCCs)
         * in a directed graph.
         *
         * @param {Array} nodes - Array of node objects, each with at least {id: string}.
         * @param {Array} edges - Array of directed edges: {source, target}.
         *                        source/target may be node objects or strings.
         * @returns {Array} array of SCCs, where each SCC is array of node IDs
         *
         * Complexity: O(V + E)
         */
        function findSCCs(nodes, edges) {
            // 1) Build adjacency list from edges
            const adj = buildAdjList(nodes, edges);

            // 2) Tarjan’s data structures
            let indexCounter = 0;
            const stack = [];
            const onStack = {};
            const index = {};     // index[nodeId]
            const lowLink = {};   // lowLink[nodeId]
            const sccList = [];   // final array of SCCs

            nodes.forEach(n => {
                index[n.id] = -1;     // uninitialized
                lowLink[n.id] = -1;
                onStack[n.id] = false;
            });

            // Tarjan’s stronglyConnected procedure
            function strongConnect(v) {
                // Set the depth index for v
                index[v] = indexCounter;
                lowLink[v] = indexCounter;
                indexCounter++;
                stack.push(v);
                onStack[v] = true;

                // Consider successors of v
                for (let w of adj[v]) {
                    if (index[w] === -1) {
                        // Successor w has not yet been visited; recurse on it
                        strongConnect(w);
                        lowLink[v] = Math.min(lowLink[v], lowLink[w]);
                    } else if (onStack[w]) {
                        // Successor w is in the stack => v is part of a cycle => update lowLink[v]
                        lowLink[v] = Math.min(lowLink[v], index[w]);
                    }
                }

                // If v is a root node, pop the stack and generate an SCC
                if (lowLink[v] === index[v]) {
                    const scc = [];
                    let w = null;
                    do {
                        w = stack.pop();
                        onStack[w] = false;
                        scc.push(w);
                    } while (w !== v);
                    sccList.push(scc);
                }
            }

            // 3) Run Tarjan’s procedure for each unvisited node
            nodes.forEach(n => {
                if (index[n.id] === -1) {
                    strongConnect(n.id);
                }
            });

            return sccList;
        }

        // Helper: build adjacency list for a directed graph
        function buildAdjList(nodes, edges) {
            const adj = {};
            nodes.forEach(n => { adj[n.id] = []; });
            edges.forEach(e => {
                const s = (typeof e.source === "object") ? e.source.id : e.source;
                const t = (typeof e.target === "object") ? e.target.id : e.target;
                if (!adj[s]) {
                    adj[s] = [];
                }
                adj[s].push(t);
            });
            return adj;
        }

        /**
         * displaySCCsInCards(sccs, containerId)
         *
         * Renders the array of strongly connected components (SCCs) as cards with a collapsible details section.
         *
         * @param {Array} sccs - Array of SCCs, where each SCC is an array of node IDs
         * @param {String} containerId - The DOM element ID where the cards will be placed
         */
        function displaySCCsInCards(sccs, containerId) {
            const container = document.getElementById(containerId);
            if (!container) {
                console.warn("Container with ID", containerId, "not found.");
                return;
            }

            // If no SCCs, display a simple message
            if (!sccs || sccs.length === 0) {
                container.innerHTML = "<p>No strongly connected components found.</p>";
                return;
            }

            // Start building the HTML
            let html = ``;

            sccs.forEach((component, index) => {
                // For brevity, show first three nodes as a summary.
                const summaryCount = 3;
                const summaryNodes = component.slice(0, summaryCount).join(", ");
                const remainingCount = component.length - summaryCount;
                const fullList = component.join(", ");

                html += `<div class="scc-card">
                <div class="scc-header">
                    <span class="scc-index">Cluster ${index + 1}</span>
                    <span class="scc-summary">
                    ${summaryNodes}${remainingCount > 0 ? " ..." : ""}
                    </span>
                </div>`;

                if (remainingCount > 0) {
                    html += `<details class="scc-details">
                    <summary>Show full list</summary>
                    <p>${fullList}</p>
                </details>`;
                }

                html += `</div>`;
            });

            container.innerHTML = html;
        }


        // Visualize the maximum clique using a circular layout.
        function visualizeClique(cliqueNodes) {
            let cliqueSVG = d3.select("#cliqueSVG");
            cliqueSVG.selectAll("*").remove();
            if (cliqueNodes.length === 0) {
                cliqueSVG.append("text")
                    .attr("x", 10)
                    .attr("y", 20)
                    .text("No reciprocal clique found.");
                return;
            }
            // Create edges for every pair of nodes in the clique.
            let edges = [];
            for (let i = 0; i < cliqueNodes.length; i++) {
                for (let j = i + 1; j < cliqueNodes.length; j++) {
                    edges.push({ source: cliqueNodes[i], target: cliqueNodes[j] });
                }
            }
            // Arrange nodes in a circle.
            let width = parseInt(cliqueSVG.style("width"));
            let height = parseInt(cliqueSVG.style("height"));
            let cx = width / 2, cy = height / 2;
            let radius = Math.min(width, height) / 2 - 40;
            let n = cliqueNodes.length;
            cliqueNodes.forEach((node, i) => {
                let angle = 2 * Math.PI * i / n;
                node.cx = cx + radius * Math.cos(angle);
                node.cy = cy + radius * Math.sin(angle);
            });
            // Draw edges.
            cliqueSVG.selectAll("line")
                .data(edges)
                .enter()
                .append("line")
                .attr("x1", d => d.source.cx)
                .attr("y1", d => d.source.cy)
                .attr("x2", d => d.target.cx)
                .attr("y2", d => d.target.cy)
                .attr("stroke", "#999")
                .attr("stroke-width", 1);
            // Draw nodes.
            cliqueSVG.selectAll("circle")
                .data(cliqueNodes)
                .enter()
                .append("circle")
                .attr("cx", d => d.cx)
                .attr("cy", d => d.cy)
                .attr("r", 10)
                .attr("fill", "#69b3a2")
                .attr("stroke", "red")
                .attr("stroke-width", 2);
            // Add labels.
            cliqueSVG.selectAll("text")
                .data(cliqueNodes)
                .enter()
                .append("text")
                .attr("x", d => d.cx)
                .attr("y", d => d.cy)
                .attr("dy", ".35em")
                .attr("text-anchor", "middle")
                .text(d => d.id);
        }

        /**
         * visualizeCliqueAsForce(cliqueNodes)
         *
         * Uses a d3 force layout to display the maximum clique as a standard graph (with edges and node labels).
         *
         * @param {Array} cliqueNodes - Each element is an object representing a node, e.g. { id, statnaam }.
         */
        function visualizeCliqueAsForce(cliqueNodes) {
            const svg = d3.select("#cliqueSVG");
            svg.selectAll("*").remove();

            // If no clique nodes, show text
            if (!cliqueNodes || cliqueNodes.length === 0) {
                svg.append("text")
                    .attr("x", 10)
                    .attr("y", 20)
                    .text("No reciprocal clique found.");
                return;
            }

            // Build pairwise edges for the clique
            const edges = [];
            for (let i = 0; i < cliqueNodes.length; i++) {
                for (let j = i + 1; j < cliqueNodes.length; j++) {
                    edges.push({ source: cliqueNodes[i], target: cliqueNodes[j] });
                }
            }

            // Convert style to numeric
            const width = parseInt(svg.style("width"), 10);
            const height = parseInt(svg.style("height"), 10);

            // D3 force simulation
            const simulation = d3.forceSimulation(cliqueNodes)
                .force("charge", d3.forceManyBody().strength(-80))  // repel
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collide", d3.forceCollide(40))              // spacing
                .force("link", d3.forceLink(edges).distance(80).strength(1));

            // Draw edges
            const link = svg.selectAll("line")
                .data(edges)
                .enter()
                .append("line")
                .attr("stroke", "#999")
                .attr("stroke-width", 1);

            // Draw node "boxes" or "labels"
            const node = svg.selectAll(".cliqueNode")
                .data(cliqueNodes, d => d.id)
                .enter()
                .append("g")
                .attr("class", "cliqueNode");

            // Draw a rect
            node.append("rect")
                .attr("width", 60)
                .attr("height", 30)
                .attr("fill", "#69b3a2")
                .attr("rx", 5)
                .attr("ry", 5)
                .attr("stroke", "red")
                .attr("stroke-width", 2)
                .attr("x", -30)   // center rect around the node’s x,y
                .attr("y", -15);

            // Add text label inside the rect
            node.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", "0.35em")
                .text(d => d.id);

            // On each tick, update positions
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("transform", d => `translate(${d.x},${d.y})`);
            });
        }

        function replotInOutArbos(newRootId) {
            // 0) Clear the existing SVGs if newRootId is null
            if (!newRootId) {
                d3.select("#inArboSVG").selectAll("*").remove();
                d3.select("#outArboSVG").selectAll("*").remove();
                return;
            }

            // 1) Find the new root node object
            let newRoot = allNodes.find(n => n.id === newRootId);
            if (!newRoot) {
                console.warn("No root found for ID:", newRootId);
                return;
            }

            // 2) Compute in-arbo and out-arbo
            let inArbo = chuLiuEdmonds(allNodes, allLinks, newRoot, "in");
            let outArbo = chuLiuEdmonds(allNodes, allLinks, newRoot, "out");
            visualizeArborescence(inArbo, "#inArboSVG", newRootId);
            // visualizeArborescence(outArbo, "#outArboSVG", newRootId);
        }

        function attachInfoBoxListeners() {
            document.querySelectorAll('.info-container').forEach(container => {
                const infoBox = container.querySelector('.info-box');

                container.addEventListener('mouseenter', () => {
                    // Get the container's position relative to the viewport
                    const rect = container.getBoundingClientRect();

                    // Detach the tooltip from its current parent and append it to the body
                    document.body.appendChild(infoBox);

                    // Set the tooltip's style to fixed positioning so it's not cropped
                    infoBox.style.position = 'fixed';
                    // Position it above the container (adjust offsets as needed)
                    infoBox.style.top = (rect.top - infoBox.offsetHeight - 5) + 'px';
                    infoBox.style.left = (rect.left + rect.width / 2 - infoBox.offsetWidth / 2) + 'px';

                    // Show the tooltip
                    infoBox.style.visibility = 'visible';
                    infoBox.style.opacity = '0.85';
                });

                container.addEventListener('mouseleave', () => {
                    // Hide the tooltip
                    infoBox.style.visibility = 'hidden';
                    infoBox.style.opacity = '0';

                    // Reattach the tooltip to the original container
                    container.appendChild(infoBox);
                    // Reset the tooltip's position so it can be absolutely positioned within the container again
                    infoBox.style.position = 'absolute';
                });
            });
        }

        // ---- CSV File Upload ----
        document.getElementById('csvFileInput').addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            // When the file is loaded, parse it as CSV
            reader.onload = function (e) {
                // Initialize data structures
                const text = e.target.result;
                const data = d3.csvParse(text);
                const nodesMap = {}, links = [];

                // Iterate over each row in the CSV
                data.forEach(d => {
                    const source = d.COROP_LEV, target = d.COROP_AFN, weight = +d.AANTAL;
                    // Skip rows if the source or target is missing/NA.
                    if (!source || !target || source.toUpperCase() === "NA" || target.toUpperCase() === "NA") {
                        return; // Just skip this row.
                    }
                    if (!nodesMap[source]) {
                        nodesMap[source] = { id: source, tradeTotal: 0 };
                    }
                    if (!nodesMap[target]) {
                        nodesMap[target] = { id: target, tradeTotal: 0 };
                    }
                    nodesMap[source].tradeTotal += weight;
                    nodesMap[target].tradeTotal += weight;
                    links.push({ source, target, weight });
                });

                // Convert nodesMap to an array of nodes
                const nodes = Object.values(nodesMap);
                allNodes = nodes;
                nodes.forEach(d => {
                    d.statnaam = (nlLabelPoints && nlLabelPoints.features) ?
                        (nlLabelPoints.features.find(f => f.properties.statcode === d.id)?.properties.statnaam || d.id)
                        : d.id;
                });
                allLinks = links;

                // Update network stats
                updateNetworkStats(nodes, links);

                // Compute and print 3 hotpots per metric
                hotspots = computeHotSpotMetrics(allNodes, allLinks);
                printHotSpots(hotspots, "topMetrics", 3);

                // Create the network visualization
                createNetwork(nodes, links);

                // Find strongly connected components (SCCs) and display them in a table
                const sccs = findSCCs(nodes, links);
                displaySCCsInCards(sccs, "sccOutput");

                // Compute and visualize the maximum clique (using reciprocal edges only)
                // let maxClique = computeMaxCliqueReciprocal();
                // visualizeCliqueAsForce(maxClique);

                // Enable toggle button now that CSV is loaded.
                document.getElementById("toggleModeButton").disabled = null;
            };

            // Read the file as text
            reader.readAsText(file);
        });

        document.addEventListener('DOMContentLoaded', function () {
            const introOverlay = document.getElementById('introOverlay');
            const okButton = document.getElementById('introOkButton');
            const dontShowAgain = document.getElementById('dontShowAgain');

            // If the user already opted to hide the intro, skip showing it entirely
            if (localStorage.getItem('hideIntro') === 'true') {
                // Immediately hide (no animation)
                introOverlay.style.display = 'none';
            }

            // Otherwise, the overlay is visible by default and can fade in
            okButton.addEventListener('click', function () {
                // If the user checked "Do not show again", store that choice.
                if (dontShowAgain.checked) {
                    localStorage.setItem('hideIntro', 'true');
                }

                // Trigger the fade-out animation by adding a 'hide' class
                introOverlay.classList.add('hide');
            });

            // Once the fade-out completes, fully remove overlay from view
            introOverlay.addEventListener('animationend', function (e) {
                // Only hide if the 'hide' animation has been triggered
                if (introOverlay.classList.contains('hide')) {
                    introOverlay.style.display = 'none';
                }
            });
        });

        // Initialize Vivus on the SVG inside the card header
        var drawDuration = 24;
        var myAnim = new Vivus('mySVG', {
            duration: drawDuration,
            start: 'autostart',
            type: 'scenario-sync'
        });

        var animator = function () {
            myAnim.play();
        };

        function fadeInNodes(step, maxStep) {
            setTimeout(() => {
                // Select all nodes for the current step
                const nodes = document.querySelectorAll('.circle.step' + step);
                nodes.forEach(node => {
                    node.classList.add('blue-bg');
                });
                if (step < maxStep) {
                    fadeInNodes(++step, maxStep);
                }
            }, 1000);
        }

        window.addEventListener('load', function () {
            setTimeout(() => {
                fadeInNodes(1, 5);
            }, 1000);
        });

        // Event listener for the file upload widget
        document.getElementById("csvFileInput").addEventListener("change", function (event) {
            const fileNameDisplay = document.getElementById("fileName");
            fileNameDisplay.textContent = event.target.files.length > 0 ? event.target.files[0].name : "No file selected";
        });

    </script>
</body>

</html>